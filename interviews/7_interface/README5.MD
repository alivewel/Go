### [Принципы SOLID в Go](https://github.com/MaksimDzhangirov/practicalSolid)

Есть 2 интересных источника, в которых можно подробнее изучить тему. [Github](https://github.com/MaksimDzhangirov/practicalSolid) одного независмого разработчика и перевод [поста SOLID Go Design из блога Dave Chene](https://habr.com/ru/articles/348852/).

### Принцип инверсии зависимостей (Буква D)

Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

Когда я вижу это определение, у меня сразу возникает вопрос, что такой модули **верхнего уровня** и **нижнего уровня**?

### Верхний и нижний уровень

**Верхний уровень** и **нижний уровень** — это термины, которые часто используются в контексте микросервисной архитектуры. Они помогают описать иерархию компонентов системы и их взаимодействие. По сути, это слои нашего микросервиса: **сontroller (контроллеры)** (хэндлеры), **logic (бизнес-логика)** и **repo (репозитории)** (базы данных). В зависимости от того, какой слой находится выше, он будет считаться **верхним уровнем**, а слой, находящийся ниже, — **нижним уровнем**.

### Пример структуры слоев микросервиса:

- **Контроллеры**: Обрабатывают входящие запросы и взаимодействуют с бизнес-логикой.
- **Бизнес-логика**: Содержит основную логику приложения и управляет процессами.
- **Репозитории**: Отвечают за взаимодействие с базами данных и хранилищами данных.

### Пример

Рассмотрим пример, где верхний уровень отвечает за обработку запросов пользователя, а нижний уровень взаимодействует с базой данных.

```go
package main

import (
	"fmt"
)

// User - структура пользователя
type User struct {
	ID   int
	Name string
}

// UserRepository - интерфейс для работы с пользователями
type UserRepository interface {
	GetUserByID(id int) (*User, error)
}

// InMemoryUserRepository - реализация UserRepository, работающая с данными в памяти
type InMemoryUserRepository struct {
	users map[int]*User
}

func (repo *InMemoryUserRepository) GetUserByID(id int) (*User, error) {
	user, exists := repo.users[id]
	if !exists {
		return nil, fmt.Errorf("user not found")
	}
	return user, nil
}

// UserService - сервис для работы с пользователями
type UserService struct {
	repo UserRepository // Зависимость от абстракции
}

func (service *UserService) GetUser(id int) (*User, error) {
	return service.repo.GetUserByID(id)
}

func main() {
	// Создаем репозиторий и добавляем пользователей
	repo := &InMemoryUserRepository{
		users: map[int]*User{
			1: {ID: 1, Name: "Alice"},
			2: {ID: 2, Name: "Bob"},
		},
	}

	// Создаем сервис и получаем пользователя
	service := UserService{repo: repo}
	user, err := service.GetUser(1)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println("User found:", user.Name)
}
```

1. **UserRepository:** Это интерфейс, который определяет методы для работы с пользователями. Он представляет собой абстракцию, от которой зависит верхний уровень.
2. **InMemoryUserRepository:** Это реализация интерфейса, которая работает с данными в памяти. Она представляет нижний уровень, который взаимодействует с конкретными данными.
3. **UserService:** Это сервис, который использует `UserRepository` для получения данных о пользователях. Он представляет верхний уровень, который управляет бизнес-логикой.
4. **main:** В функции `main` создается экземпляр репозитория и сервиса, и выполняется запрос на получение пользователя.

Верхний уровень (`UserService`) зависит от абстракции (интерфейса `UserRepository`), а не от конкретной реализации (InMemoryUserRepository`). Это позволяет легко заменять нижний уровень, не затрагивая верхний, что делает систему более гибкой и удобной для тестирования.
