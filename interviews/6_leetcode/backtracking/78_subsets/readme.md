В этом коде происходит **создание независимой копии среза `subset`** и добавление этой копии в срез `allCombinations`. Разберём по шагам:

---

### **1. `append([]int(nil), subset...)`**
- `[]int(nil)` создаёт **пустой срез** типа `int` (с нулевой ёмкостью).  
- `append` добавляет в этот пустой срез все элементы из `subset` (оператор `...` распаковывает `subset`).  
- **Результат**: новый срез `copySubset` с такими же элементами, как у `subset`, но с **новым underlying массивом**.  

**Пример**:  
```go
subset := []int{1, 2, 3}
copySubset := append([]int(nil), subset...) 
// copySubset = [1 2 3], но это новый срез в памяти!
```

---

### **2. `allCombinations = append(allCombinations, copySubset)`**
- Копия `copySubset` добавляется в срез `allCombinations`.  
- **Важно**: Мы добавляем именно копию, а не оригинальный `subset`, чтобы избежать:
  - Изменения элементов `subset` в будущем (если `subset` будет модифицирован, это не затронет уже добавленные комбинации).  
  - Случайного переиспользования памяти (если добавлять `subset` напрямую, все элементы `allCombinations` могут ссылаться на один массив).

---

### **Зачем это нужно?**
Представим, что `subset` изменяется в цикле, а `allCombinations` должен сохранить все его промежуточные состояния:
```go
var allCombinations [][]int
subset := []int{1, 2}

for i := 0; i < 3; i++ {
    subset = append(subset, i)       // Модифицируем subset
    copySubset := append([]int(nil), subset...)
    allCombinations = append(allCombinations, copySubset)
}

// Без копирования все элементы allCombinations 
// содержали бы [1 2 0 1 2], так как ссылались бы на один subset!
fmt.Println(allCombinations) 
// С копированием: [[1 2 0] [1 2 1] [1 2 2]]
```

---

### **Альтернативные способы копирования среза**
1. **Через `make` + `copy`** (более явный вариант):
   ```go
   copySubset := make([]int, len(subset))
   copy(copySubset, subset)
   ```

2. **Через `append` с пустым срезом** (как в вашем коде — лаконично).

3. **Если элементы — структуры или указатели**, нужна **глубокая копия** (например, через `json.Marshal/Unmarshal`).

---

### **Когда это применяется?**
- При работе с **рекурсивными алгоритмами** (например, генерация подмножеств, комбинаторика).  
- Когда нужно сохранить **независимые копии** изменяемых данных.  
- В **многопоточных** программах (чтобы избежать гонок за данные).  

Если бы вы добавляли `subset` напрямую, все элементы `allCombinations` ссылались бы на один массив, и их значения менялись бы синхронно с `subset`. Копирование предотвращает это.