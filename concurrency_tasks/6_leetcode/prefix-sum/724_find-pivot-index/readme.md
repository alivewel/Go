Дан массив целых чисел nums, вычислите индекс поворота этого массива.

Сводным индексом называется индекс, в котором сумма всех чисел, расположенных строго слева от индекса, равна сумме всех чисел, расположенных строго справа от индекса.

Если индекс находится на левом краю массива, то левая сумма равна, 0поскольку слева нет элементов. Это также относится к правому краю массива.

Верните самый левый индекс поворота. Если такого индекса не существует, верните -1.

-------------

Самый простой способ решить задачу использовать префиксный и суффиксный суммы. Мы проходимся по этим массивам и там, где значения совпали там и есть индекс поворта этого массива. Проблема в том, что это решение не оптимальное. Суффиксная сумма - это тоже самое, что и префиксная сумма, только мы проходимся с конца, там получаются совсем другие значения.

![1](<1.png>)

-------------

Второй способ (оптимальный):

Сначала нам нужно пройтись по массиву и найти сумму всех элементов в массиве - allSum.

Далее снова проходимся по массиву и находим текущую сумму элементов в массиве - pxSum. С каждой итерацией эта сумма будет увеличиваться и мы может найти индекс поворота этого массива, сравнивая значения по формуле allSum - curElem (текущий элемент) - pxSum. Тем самым мы сравниваем сумму справа и сумму слева, эти суммы должны быть равны.

![2](<2.png>)

Оценка по времени и памяти:
time: o(2n) = O(n) - оценка сверху.
О маленькое от 2n равно о большое от n.
mem: O(1)

Как оценилась память в O(1)?
У нас есть входной массив, он может изменяться. Это единственный изменяемый параметр в функции. O(1) говорит нам о том, что у нас память при каждом запуске наша память будет одна и та же независимо от размера массива. O(1) говорит нам о том, что затраченная память - это константа. Мы всегда используем 2 переменные allSum и pxSum.
