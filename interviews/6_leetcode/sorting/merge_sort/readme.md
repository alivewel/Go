Давайте разберем сортировку слиянием (Merge Sort) на Go.

## Принцип работы Merge Sort

Сортировка слиянием использует принцип "разделяй и властвуй" и состоит из двух основных операций:

1. **Разделение (Split)**:
   - Массив рекурсивно делится на две равные части, пока не останутся подмассивы из 1 элемента
   - Массив из 1 элемента считается отсортированным

2. **Слияние (Merge)**:
   - Два отсортированных подмассива объединяются в один отсортированный массив
   - Сравниваются элементы из обоих подмассивов и помещаются в результирующий массив в правильном порядке

```go
// Основная функция сортировки слиянием
func MergeSort(arr []int) []int {
    // Базовый случай: если длина массива <= 1, он уже отсортирован
    if len(arr) <= 1 {
        return arr
    }

    // Находим середину массива
    mid := len(arr) / 2

    // Рекурсивно сортируем левую и правую части
    left := MergeSort(arr[:mid])
    right := MergeSort(arr[mid:])

    // Объединяем отсортированные части
    return merge(left, right)
}

// Функция слияния двух отсортированных массивов
func merge(left, right []int) []int {
    result := make([]int, 0, len(left)+len(right))
    leftIndex, rightIndex := 0, 0

    // Сравниваем элементы из обоих массивов и добавляем меньший в результат
    for leftIndex < len(left) && rightIndex < len(right) {
        if left[leftIndex] <= right[rightIndex] {
            result = append(result, left[leftIndex])
            leftIndex++
        } else {
            result = append(result, right[rightIndex])
            rightIndex++
        }
    }

    // Добавляем оставшиеся элементы из левого массива
    result = append(result, left[leftIndex:]...)
    // Добавляем оставшиеся элементы из правого массива
    result = append(result, right[rightIndex:]...)

    return result
}
```

## Пример использования:

```go
func main() {
    arr := []int{64, 34, 25, 12, 22, 11, 90}
    fmt.Printf("Исходный массив: %v\n", arr)
    
    sortedArr := MergeSort(arr)
    fmt.Printf("Отсортированный массив: %v\n", sortedArr)
}
```

## Пошаговый процесс работы алгоритма

Для массива `[64, 34, 25, 12]`:

1. **Первое разделение**:
   ```
   [64, 34, 25, 12]
   ↙            ↘
   [64, 34]    [25, 12]
   ```

2. **Второе разделение**:
   ```
   [64, 34]    [25, 12]
   ↙    ↘      ↙    ↘
   [64] [34]  [25] [12]
   ```

3. **Первое слияние**:
   ```
   [64] [34]  [25] [12]
      ↘  ↙       ↘  ↙
   [34, 64]    [12, 25]
   ```

4. **Финальное слияние**:
   ```
   [34, 64]    [12, 25]
        ↘        ↙
   [12, 25, 34, 64]
   ```

## Характеристики алгоритма

1. **Временная сложность**:
   - В лучшем случае: O(n log n)
   - В среднем случае: O(n log n)
   - В худшем случае: O(n log n)

2. **Пространственная сложность**: O(n)
   - Требуется дополнительная память для временных массивов

3. **Преимущества**:
   - Стабильная сортировка (сохраняет порядок равных элементов)
   - Предсказуемая производительность
   - Хорошо подходит для сортировки связных списков

4. **Недостатки**:
   - Требует дополнительную память
   - Для маленьких массивов менее эффективен, чем простые алгоритмы (например, сортировка вставками)

## Оптимизации

1. **Использование буфера**:
   - Можно создать буфер заранее и переиспользовать его
   - Уменьшает количество аллокаций памяти

2. **Гибридный подход**:
   - Для маленьких подмассивов (например, < 10 элементов) использовать сортировку вставками
   - Улучшает производительность на практике

3. **Параллельная версия**:
   - Разные части массива можно сортировать параллельно
   - Эффективно на многоядерных процессорах


--------------

Сортировка слиянием:
https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D1%81%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D0%B5%D0%BC
