### Worker Pool

Довольно часто в архитектуре встречается случаи, когда работа осуществляется через какие-то очереди. С которыми работают оффлайновые разгребаторы. Часто для этих целей есть воркающиеся демоны, но в го можно поступить гораздо проще. Мы можем создать несколько горутин, которые будут читать из какого-то канала и если к нам приходит какая-то задача мы будем писать ее в этот канал.

У нас есть 3 воркера, которые выводят что-то на экран. Внутри функции мы читаем из канала и выводим прочитанное значение на экран. При этом если нам больше не нужен пул воркеров, мы можем просто закрыть этот канал. И когда цикл который крутиться внутри воркеров прервет свою работу. При этом если не закрыть этот канал и запустить программу, мы увидим, что сообщение 'Worker # finished' не выведется на экран. 
Почему так происходит? Мы не дождались выполнения работы воркера. Горутина main завершила свою работу и стала ждать выполнения других горутин. Поэтому воркер завершился некорректно. В других случаях это может привести к утечкам горутин и деадлоку. Будьте осторожны.

Мое примечание: 

1) runtime.Gosched() // попробуйте закомментировать
В версии Go до 1.14 планировщик был кооперативный, это значит что он не трогал горутины до тех пор пока она не выполнит свою работу. Для того, чтобы передавать управление другим горутинам нужно было принудительно вызывать функцию runtime.Gosched(). 
В версии Go 1.14 планировщику добавили вытесняющую многозадачность. Теперь он тоже может снимать горутины с выполнения один раз в 10мс.
Подробнее можно прочитать здесь: https://habr.com/ru/articles/502506/

2) close(worketInput) // попробуйте закомментировать
Если закомментировать строку с закрытием канала мы увидим, что printFinishWork не отрабатывается. Это связано с тем, что мы остаемся в цикле for range, который завершится только в случае закрытия канала. Управление к printFinishWork перейдет только, когда мы выйдем из цикла for range. Можно сказать, что закрытие канала в этом коде работает как примитив синхронизации.
