### Rate Limit

Довольно часто нам нужно каким-то образом затормозить нашу программу, например в зависимости от утилизации процессора или дисковой подсистемы нам нужно уменьшить нагрузки на эти части. В го мы можем реализовать это используя буфиризированные каналы.

Если мы запустим код, то увидим, что сначала запускаются горутины под номером 0 и 1, потом горутины с номером 2 и 3, потом 4.

Давайте посмотрим код. Для начала мы создаем WaitGroup, чтобы контролировать работу горутин. После этого создаем канал с квотой. Это буфиризированный канал, где размер буфера является нашим лимитом. Далее мы передаем канал с квотой в наш воркер, который выполняется в отдельной горутине.

Что происходит в воркере? Прежде чем начать выполнять какую-то полезную работу воркер пытается взять слот на эту работу. В данном случае мы берем пустую структуру в канал. Если буфер канала заполнен, значит 2 воркера уже работают. Мы блокируемся до тех пор, пока там не освободиться место. Таким образом мы не позволяем расти количеству работающих горутин сверх квоты. Далее мы выполняем работу, в нашем случае это вывод на экран сообщения. Далее возвращаем слот в работу. Мы читаем из канала quotaCh тем самым освобождаем буфер канала.

Попробуем раскомментировать условие if j%2== 0 в функции startWorker. Если ранее мы выполняли подряд операции всех горутин, то теперь у нас выполняется по 2 операции одной горутины, потом другой и так далее. То есть воркер не полностью захватывает всю работу и выполняется доконца, а дает возможность выполнять ее другим воркерам, делиться пропускной способностью, ресурсами программы. При этом условие одновременной работы не более двух горутин выполняется.
