Группировка анаграмм

На вход приходит массив:
strs = ["ab", "bat", "ba", "tab", "apt"]
Нужно вернуть:
result = [["ab", "ba"],["bat", "tab"],["apt"]]

---------

Что мы можем сделать? 
Мы можем пройтись по строке, отсортировать каждое элемент и добавить его в хэш таблицу (ключ - отсортированный элемент, значение - нетронутный элемент), потом сгруппировать по ключу и переложить в двумерный массив.

![1](<1.png>)

Проблема этой задачи в том, что первое, что приходит в голову при решении использовать стандартную сортировку в языке. Зачастую  сложность станадртных сортировок, встроенных в язык, Nlog(N). Это неоптимальное решение. Тогда общая сложность будет time: m * nlog(n), где m - количество элементов в исходном массиве.

Мы можем для оптимизации использовать count sort сортировку. count sort - подразумевает, что на выходе у нас имеется массив или хеш-таблица, в которой указано, сколько раз у нас встретился каждый символ (ключ - символ, значение - количество раз, которое он встретился в строке).

![2](<2.png>)

Массив использовать в качестве count sort, только, когда нам заранее известен алфавит (желательно, чтобы это были ascii-символы английского алфавита в lower-case). Мы заранее создаем массив с 26 элементами и говорим, сколько раз у нас встретился определенный символ (a: arr[0], b: arr[1] и т.д.)

![3](<3.png>)

В каждом языке есть операция ord() - получение кодового символа из таблицы ascii. В Go можно просто вычитать символы 'c'-'a'.

Мы проходясь по каждой строке получаем массив count sort, который будет выступать ключем в нашей хэш-таблице. Далее нам остается только пройтись по хэш-таблице и перевести в двумерный массив, чтобы вернуть его в качестве результата.

---------

time: O(m * n), m - общее количество строк, n - длина самой длиной строки.
mеm: O(m * n), m - общее количество строк, n - длина самой длиной строки. По сути это общее количество символов во всех строках. Потому что, мы проходимся по каждому символу каждой строки.
