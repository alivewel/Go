GOLANG СОБЕСЕДОВАНИЕ LAMODA НА 300К - YouTube
https://www.youtube.com/watch?v=G961oui7jeE

Transcript:
(00:01)  Привет.  Привет.  Леонид, приветствую.  Сегодня проведем техническое собеседование.  Оно будет состоять из трех частей.  В первом минуту 15 говорим об предыдущих проектах,  местах работы.  Дальше часть по ГО.  То есть походим немножко немножко поспрашиваю просто и третья часть это заброски подписать тоже говорим  еще заключительная часть когда уже тогда можешь задавать вопросы про нашу камеру. Окей, понял.
(00:48)  Тогда предлагаю начать.  Скажи, пожалуйста, про предыдущие проекты.  Какие, может быть, интересные случаи были,  какие у нас были стандарты?  Ну, проекты у меня, то есть я успел проводить в ядре в МТСе,  все на Гошке, в ядре...  Ой, я сам себя слышу.  Все, больше не слышу.  В ядре, наверное, самый такой необычный опыт был,  потому что там не просто, там, не знаю,  backend какой-нибудь там, а там, типа,  базовые станции, короче, мы разрабатывали.
(01:18)  Вот, как бы, в основном, ну, типа,  я не знаю, ладно, у нас 15 минут,  я поподробнее могу рассказать.  Типа, базовая станция, ну, по сути, это, типа,  сервак на Linux, ну, просто. И там, как бы,  если какое-то сетевое взаимодействие происходит между компонентами,  то это все в рамках одного сервака.  Вот. Там много разных компонентов.
(01:32)  Большинство из них  написано на C. Но вот один из них,  который мы писали, он написан на Гошке, и  по сути, он из себя представлял опишку базовой  станции, в которую ты можешь  обратиться и как-то сконфигурировать базовую станцию.  Там, поворот антенн,  там, я не знаю, там, радиомодуль, там, посмотреть все аварииигурировать базовую станцию.
(01:46)  Там поворот антенн, там что-нибудь, я не знаю, там  радиомодуль, там посмотреть все  аварии, которые на базовой станции есть,  там типа и куча вообще там  параметров, я даже большую часть из них не знаю,  вообще там страшные названия.  Там типа на Гошке,  вот удивительно, там как бы  у нас вот этот наш компонент,  она короче была на микросервисах,  но как бы там это  микросервисная архитектура не назвать,  потому что там у нас всего полядра было для этого,  они не скейлились как бы никак, то есть по сути распределенный монолит просто был.
(02:14)  По брокеру сообщения общались, там все антипаттерны были соблюдены  и паттерны нарушены, потому что там брокер сообщений был NSQ,  ну, типа, довольно быстро, еслиений был NSQ, ну, типа,  довольно быстро, если на него большую нагрузку не класть, но через него  синхронные вызовы тоже производились, поэтому,  ну, короче, никакого gRPC там  ничего не было, через брокер сообщений синхронно общались.
(02:37)  Вот.  Там куча всяких технологий было,  которые вообще никто никогда не слышал,  типа, сисрепа, там, это,  хранилище, нетконов там короче куча сил  такой вот еще успел поработать в рамках же ядра только уже не базовая станция систему проявления  базами станциями это короче же типа в морда там для операторов чтобы не там зашли там сразу там  перезапустили там 10 тысяч базовых станций там санкт-Петербурге. Вот что-нибудь такое. Там уже такой популярный стэк.
(03:06)  Там уже, короче, у нас все в Кубере запускалось.  Ну, в докер-контейнерах, понятное дело.  Там уже и GRPC у нас было.  Вот, Кавка.  Ну, я суперплотно с Кавкой так и до сих пор не поработал.  Ну, просто, типа, там кинуть, прочитать.  Вот.  Ну, это вот в ядре было.  Вот.  Потом в НТС.  Если что, вы меня останавливайте.
(03:27)  Просто везде по-разному там про спорта рассказывать где-то быстро это не быстро вот потом вот в мтс пошел до сих пор  сижу тут уже прям что такого необычного нету по сути ну travel просто баккант как бы вот самому вот стандартном представлении вот самый вот обычный стек типа просто вот даже  рассказывать ничего ну просто типа все все на башке в докер контейнерах все в кубе ли ковка  все gpc где хочешь там ради себе поднимаешь где хочешь там пас гриб поднимаешь чё хочешь короче делаешь вот  сейчас я вот именно в отделе маркетинга маркетинга вот там все кипар маккоды там
(04:16)  скидки рекламной кампании хорошо посылаем как я попросики задаю общие по техническому степу, так скажем. Смотри, как думаешь, вот Кавка, она отказоустойчивая за счет чего? То есть какая есть там особенность?  специалист к сейчас попробую так прикинуть почему она отказустойчива то что она поддерживает ну во первых на там пик пишет на диск короче там дни типа дампу свои во вторых там можно настроить  у низкой реплик чтобы короче она там не полноценно блин такие конечно девоксовский  темы огорующая сказка очень плохо работал стандартно тем этом реплики дампинг вот это все это все оба гарантии доставки знаешь какие
(05:10)  представляют в рамках короче сколько я помню в рамках одного кластера она нам это обещает что  у нас все будет короче в том порядке что мы что мы отправили. То есть порядок доставки будет соблюден.  И то, что в целом сообщение будет доставлено.  То есть если мы отправили в Кавку, получили ок,  то все это сообщение не потеряется.
(05:36)  И на принимающей стороне мы можем его как-то заасептить.  Потому что мы его приняли.  Можно нам больше не пытаться его пройти.  Есть такая штука уанс это мы отправим сообщение и она может быть будет доставленао, а если будет, то не больше, чем один раз.  Ага.  Ну, это типа мы отправляем,  и оно хотя бы один раз точно будет доставлено.
(06:18)  А может, не один.  А вот если не один раз, то это нормально вообще.  И что продолжилось сделать, если бы у нас бизнес-логика была бы чувствительна к дубликату?  Не использовать инструмент, который нам... Это лист он говорит.  Ой, блин, сказал же, что я не профессионал в Кавке.  Так, ну окей, то есть мы используем какой-то инструмент, он у нас там типа...
(06:46)  Обычно, если у нас какая-то такая тема,  что у нас там шина данных, она  может доставить,  может не доставить, может доставить несколько раз,  то я обычно использую это не как какое-то средство общения,  а просто, не знаю, какие-то метрики,  поток данных, просто метрики  собираем и куда-нибудь складываем.  Но если мы чувствительны к этой теме,  не знаю,  вроде кафе этим не страдает она гарантий не обеспечивает защита дубликатов и мидов и крис once он как бы может мы можем наблюдать дубликат так тогда такой вопрос чем как думаешь о микро сервисной архитектуры какие плюсы и минусы
(07:28)  ну вообще сейчас уже у нас практически везде на микросервисе если это не имбеддинг типа с  точки зрения менеджмента это проще потому что ты можешь разделять дваоны ответственности очень так хорошо, типа на команды, на людей.  Техническая часть  микросервиса у нас, если  нормально сделать, это  более надежная система получается,  потому что мы можем несколько реплик  все поднять.
(07:58)  Если у нас там какая-то реплика  падает, у нас есть другие. Если у нас весь реплик  падает, у нас скорее вся система  не упадет, опять же, если там нет  каких-то единых точек отказа. Плюс с помощью к сервисов можем как бы довольно масштабной системы строить и опять  за счет того что мы их можем масштабировать если нас там типа слова забыл если нас стоит вас как  короче микросервис то можно вообще там без проблем в этом скелет вот эти по в ширину там просто низкий  сиропов купили и поехали вот то есть  с монолитом это раз сложнее сделать монолиты тоже я знаю там скелет но совсем сделать
(08:32)  есть такая штука как распределенная транзакцияустим, у нас есть ряд микросервисов, мы хотим  выполнить какой-то вот такой процесс,  который все эти микросервисы затрагивает.  И, ну, так как  у нас распределенная система,  транзакцию мы себе позволить не можем,  а БД, да,  ну, я имею в виду в рамках одного  сервиса.
(09:02)  Как бы ты  предложил, то есть, слышал какие-то  паттерны, которые вот позволяют такие транзакции  реализовывать вообще сейчас мы можно сразу не минусе стоит этот вопрос насколько помню что-то  там типа в какой-то файл или в пасбурю может писать короче это шареные данные и через них как-то синхронизировать эти постоянные сервис про саги не читал так у вас есть вопросы части ну да у меня вопрос микросервисной архитектуре только вообще ненадежная то  есть какой-то запрос не пройти повторно начать проходить вот как решается проблема что один и например может из той же системы очереди или из ну обычно типа если мы со стороны микросервиса
(10:12)  там нам мы просто предоставляем api а там же кто нам чё как сколько отправит столько все мы  сделали сообщение может прийти два раза и не хотелось бы два раза повторить?  Тут уже смотря какая бизнес-логика. Потому что если нам просто приходит какой-нибудь сервис погоды,  понятное дело, ничего такого, что нам 500 раз один запрос придет.
(10:37)  Если у нас платежные транзакции, тогда нужно думать, как это сделать.  Обычно на каждую операцию  какой-нибудь юид ставится,  и мы смотрим, что мы делали в этой операции или нет.  Или как-нибудь по запросу хэш считается,  смотрим, что мы такого делали,  уже ли не делали.  Но тут надо на бизнес-логику смотреть,  почему нам вдруг плохо,  что нам два раза один запрос пришел.
(11:07)  Тогда предлагаю дальше пойти, да?  Идем тогда  к первой части.  Говорите, я тогда слово передаю?  Ага, хорошо.  Так, я сейчас поделюсь ссылочкой  на редактор,  где мы будем писать код.  Запускать ничего не надо пока в уме  запускать и анализировать скажи когда проще  все зашел отлично вопрос такой что выведет эта программа она не она немножко с подвохом поэтому быть внимателен и для удобства может комментарии слайс 123 один, два, три. Мы, ну, понятно. Так, ну, короче, у нас есть...
(12:06)  Мы взяли от этого слайса, делали еще один слайс,  который только первый элемент хранит.  То есть SRC у нас, ну, типа у них базовый массив один,  но вот SRC у него лен один,  поэтому в SRC только один как бы видно.  Вот, мы этот слайс кидаем сюда,  тут он аппендится.  А, ну, короче,  да, и в array у нас будет  1, 5, 3. Вот.
(12:32)  Ну,  а в SRC он не изменится, потому что  тут у нас, когда мы передали  функцию, там, типа, как бы, несмотря на то,  что память у нас та же, но сама  структура вот эта  другая, поэтому у нас  аппенд и мы сохраним в сердце уже в другой слайс который  пересечении функций как бы уже все но память не поменяли короче в сердце у нас так и останется запустим да да и она все правильно но это круто на самом деле многие ошибаются  здесь а так ну да да там сразу очевидный вопрос из чего так устроен слайс? Ну, это структура,
(13:27)  там указатель на память,  лен и капасити.  А как аппенд работает?  Аппенд, он,  короче, если у нас лен меньше, чем капасити, тогда он  в тот же базовый массив там докидывает  еще элемент и возвращает  слайс новый, у которого просто лена один больше вот  а если короче у нас нет уже место то там тип перевыделения памяти происходит там новый базу  и массив ищем он там на небольших размерах там в два раза короче каждый раз больше там на больших там уже всякие оптимизации. Понятно.
(14:06)  Хорошо.  А вот доступ к элементу массива  алгоритмической сложности у нас какая?  Индексация от единицы.  Там как бы нам не важен индекс.  Ага. А тогда мы добавляем  элемент в конец?  Да. Да, ща, ну, короче, блин, ща подумаю.  Когда добавляем, ну, типа у нас, если есть место,  то, по сути, нам не важно, там, какой длины тоже от одного.
(14:41)  А если пересобираем, то там уже, блин, нужно смотреть,  как там вообще локатор кошки там за  такое время вообще ищет новую память но если память их достаточно то типа завод 1 потому  что все равно понятно хорошо а как бы программу исправил чтобы не было сайта еще ну потому что здесь прикол что меняет вроде на первой скопировать туда рей отлично хорошо а вот если мы выделили массив он нам больше не нужен как  есть какая-то конструкция чтобы можно было переиспользовать это же память этого массива не выделяет новый. Или даже слайс. Нет, ну, конечно,
(15:47)  типа, если он просто у нас останется,  если он у нас там в стеке, если мы напишем код так,  что он у нас остается в стеке, или там,  типа, если мы там какой-нибудь указатель на него прокинем,  что он в кучу попадает, ну, да, типа,  ну, я не очень понимаю,  ну, вот мы создали слайс, там, как хочешь,  эту память используй, типа, добавляй, удаляй.
(16:04)  Если там хочешь какой-то новый слайс,  там, с другим типом данных, ну нет башка такой не представляет нету там как в плюсах там будет звездочкой она хотя есть это и не но короче ну я честно вопрос по последнему вопрос скорректирует допустим цикле ты копируешь постоянно слайс что-то знаешь  что у тебя входящие данные они какого-то размера но максимально ты знаешь, что они там достаточно. Да, ну да, я понял.
(16:46)  Вопрос про аргументы Мэйка, там, потому что  можно сразу, короче, несколько элементов  создать, и чтобы он был  и длины, и капасити, там,  типа, пять условно. А можно просто  капасити выделить, а лен как бы ноль.  Ну да, типа, предвыделить память можно.  Ну. Уже мне  все-таки предложение, вот, то, что  Андрей спрашивал по поводу  то, как исправить эту программу, да.
(17:14)  Можать как-то на хотелось взять ну типа из исправить это какой тогда  у нас вообще результат может быть 123 учиться в окей так ну типа получается срц там типа мы и кайма 8 3 вот и тут ой забыл  наверное слева действий типа к куда мы копируем тут откуда забыл короче только только немножко результат получится не только торговать то есть нашим было скопировали короче туда так нужно чтобы сердце один было тут 1 2 3 на корж  понятно 1 2 3 поэтому мы я просто в принципе ну типа ничего можно тогда не  делать за сердце просто и еще и просто ну ладно ну вот и пока как и просто ну ладно, я какие-то...
(18:33)  Ну вот, типа как и было, то есть мы в целом просто лент уменьшили, типа и все. А если вот так сделаем, то?  Насколько я помню, копия, короче, скопирует только первый элемент.  Это то, что надо, так все скопирую элемент ну вообще у нас тут уже  другой базы массив будет вот поэтому типа когда мы тут за поедем то уже в другую короче пойдет память поэтому насколько я понимаю она заработает у нас вот такая программа не  начал просто расскажешь про найти боится ну и потом по критику так слайс урлов мы идем по
(19:30)  ворлам запускаем гарутину урал копируется у нас так что фенор фетчинг что-то там яркий шкуру так ok я равно не ларри тюрн так ну чё у нас  запускается 4 гарантии на каждой из них делать вечеру и потом и 400 миллисекунд ждем короче пока не то все принтер свои сделают чтобы здесь да ну типа тут это time time sleep такое себе типовой группы давайте повесим синке просто для простоты И вот в гарутинке у нас тут... Так, что-то у меня...
(20:47)  Вг... Да. Вот, ну и тут all request launched, ну и тут вот ждём.  Ой, ой, ой. Всё, забыл.  Хорошо. А почему нельзя было добавить в VG Add в Google?  Да можно было. Можно вот типа...  Ну, так как-то канонично, типа, я не знаю, сразу вот на глаз проще воспринимать,  что вот мы прямо перед запуском добавляем,  ну, прямо перед запуском крутин добавляем в wait-группу,  и потом сразу же типа ждем.
(21:26)  Ну конечно,  типа никто не мешает вот здесь вот add и там типа len urls. Ага, да, отлично. Нет, я имел ввиду,  вернее, как было. Почему нельзя вот add добавить, например, перед defer, прямо на уровне функции. А, типа прямо в гарутине?  Да.  Написать-то можно, но в чем прикол?  Если у нас мы будем добавлять  единички в  вейт-группу прямо в гарутине, то что может произойти?  Мы там  запустим из гарутина, они там пока попадут  в свои локальные очереди,  пока их машина на ядро пустит,  короче, у нас мы уже можем дойти  до 38 строчки увидеть что мы ничего не запустили и программа завершится хорошо вечно а какой
(22:16)  последовательности у планировщиков спросить для нас случайно хорошо а давай а вот если у вас здесь будет допустим не 4 урл а  не знаю 100000 и не будет сложности возможно да у нас типа могут закончиться порты, в принципе, куда мы ходим.  Да и в целом, насколько я помню, сейчас пальцы в небо, что вроде Linux-системы одновременно до 10 тысяч соединений на одном хосте могут держать.
(23:00)  В любом случае, даже если не порты, а еще дескриптор файловой системы у нас тоже  там бесконечный вот короче любом случае проблем могут быть весьма там в одну секунду 100 100  тысяч запросов запустим а хорошо а как это нужно было решить мы могли просто запустить ну типа в общем говоря нам нужно  ограничить количество запускаемых гарутин то есть ограничить запросов вот как мы это могли бы сделать  у нас бы могли быть какие-то гарутины типа там worker вот который просто слушает какой-то канал  входящий вот и мы там запускаем сразу тысячу этих воркеров.
(23:47)  И потом в этот канал, ну, канал буферизированный какой-нибудь, и мы в него просто пишем наши урлы.  И, соответственно, они вот так вот будут этими тысячу гарутинами там по чуть-чуть обрабатываться.  Хорошо. А вот ты упомянул планировщик. А можешь чуть подробнее о нем рассказать?  Ну, планировщик в Гошке, то есть это вот часть рантайма, насколько я помню.
(24:13)  То есть он управляет как бы гарутинами, короче говоря.  Вот, то есть, ну, я так понимаю, вопрос про именно планировщик в Гошке?  Да, конечно.  Да, вот, то есть модель вот эта вот Gжим пи у него типа гарантий на машина  процессор то есть у нас есть сущность это гарантия то есть какие-то потоки исполнения  у нас есть и машины там так называемые то как бы сущность которого тип сидит на игре она там вот  может свою локальную доставать гарантий ну и там кидать ее на исполнение вот сами грудь и там что есть три стоит а короче
(24:48)  типа готова к выполнению выполняется и там типа на паузе вот ну и соответственно там типа он  запускает эти гарутины которые готовы выполняться когда там какие-то гарутины ставится на паузу он  их вытесняет да там ставит на исполнение другие.  Можно сказать про всякие типа стилинг-гарутин,  то, что если одна машина сильно нагружена,  у нее много гарутин в очереди локальной,  а вторая чилит,  то эта вторая будет брать  гарутинки из локальной очереди первой,  чтобы распределить нагрузку по ядрам.
(25:24)  Хорошо. А вот все-таки грудь и наши такое это типа трек операционных систем  чем-то отличается ну да отличается от рейда ну как бы сразу по легковесный поток почему  легковесный потому что происходит переключение грудь in в рамках одного физического потока то  есть если на станку и длинных стрит надо переключить антона д рамках одного физического потока, то есть если у нас там какой-нибудь Linux thread надо переключить,  нам то надо, короче, все его регистры  куда-то запомнить, там все какие-нибудь  процессорные кэши там куда-то запомнить, короче.
(25:52)  Потом найти,  короче, этот стэк этого  процесса, там все это, ой, этого  потока, все это, короче,  куда-нибудь выгрузить, а потом еще  тот, на который мы хотим переключиться, это все  нам вот так обратно нужно закинуть, поэтому на который мы хотим переключиться, это все нам обратно нужно  закинуть. Поэтому это долго.
(26:11)  Переключение Garoutine происходит в рамках одного физического потока,  то есть это как раз машина является этим потоком, поэтому это все быстро происходит.  А как ты переключишь вообще Garoutine? Ты все равно его переключаешь, не сохраняяя стек, контекст, стек регистра и прочее.  Ну я честно, Гарутина руками не переключала, не знаю.  Не, я знаю, никто не переключал руками, делает планировщик, просто сказал, что это дорого,  потому что нужно сохранять регистры, там еще что-то, найти стек и прочее.
(26:39)  А разве когда переключаешь Гарутина, это всего не надо делать?  Ну у нас там типа один поток. Какая разница,  ты переключаешь кусок кода на процессор, ставишь, он должен выполнить. Как процессор будет знать,  что ему нужно выполнить другой кусок кода? Ну как там, в процессоре как это называется? Те же самые  регистры надо переключить, я сложу вопрос к тому, что то же самое переключение происходит,  все это сохраняется и все переключается. Но почему-то Гуарутины переключаются быстрее, чем Трэд.
(27:13)  В операционке почему? Почему? Тогда не знаю, почему они так переключаются. Окей, тогда поехали дальше.  А в какой момент вообще происходит переключение? Понятно, что у процессора, допор допустим 816 ядер а грудью  может быть тысячи вот какие момент происходит переключение исполнения  типа когда у нас какая-то гарантийная либо там к тетевой запрос делает она там  теперь ходит сцене паузы и соответственно эти посмеяют либо короче там с как какая-то гарутина либо там какой-то сетевой запрос делает, она там переходит в состояние паузы, и, соответственно, ее сменяют.
(27:48)  Либо, короче, там с какого-то, начиная с какой-то версии Гошки,  у нас если какая-то гарутина очень долго там сидит на ядре,  то ее просто в рандомный момент времени могут вытеснить и сменить другой.  Хорошо. Так, у нас ты говоришь так там и делаем сетевой запрос да что с тем происходит  сделали сетевой вызов куда м подавать ну это же машина она типа никуда не девается  надо она так и сидит на ядре.
(28:46)  Гарутина переходит в состояние паузы, потому что она залочена на сетевом запросе.  Ее выкидывают с ядра в локальную очередь.  Потом, когда к ней уже придет ответ, она перейдет в какое-то состояние готова к исполнению.  И когда ее очередь наступступит она опять на процессор  а вот над поля такое слышал понятие  осмаря допустим когда мы файлик читаем то есть у нас с тем что происходит  отличаться  почему что-то должно происходить типа мы же читаем там не знаю отмены хотят ответ я могу немножко по-другому перефразировать вот если отличие когда мы делаем сетевой вызов и сискол, который, допустим, файл
(29:47)  когда читаем?  То есть этим M  мы можем воспользоваться для дальнейшей  обработки, допустим,  при сетевом вызове  и при чтении файла?  Ну, не, мне сейчас только гадать,  не знаю. Ну, могу тебе предположить,  но, короче, я не знаю.  Типа, когда сетевой у нас вызов,  то там...  Типа, в сетевой вызов,  если у нас syscall, то...
(30:12)  Блин, я уже слабо помню, но насколько я помню,  какой-то syscall, это мы просто...  Ну, ядро, которое у нас выполняло  программу, оно типа...  Вот этот счетчик команд  перекидывает на область памяти,  где у нас системные команды. То есть, по су мы все равно как бы какой-то деятельностью занимаемся  да наш там равенство в том что  листем вызовем отрядом воспользоваться можем потому что он не хочется  вот а прискоре  трат лочится и как бы мы воспользоваться уже не можем, пока не закончим  систему.
(30:46)  Ну, да.  Окей, Ландриан,  передай смысл.  Хорошо. Ну вот, возвращаясь  к нашу программу,  у меня такое вот пожелание  есть. Допустим, у нас эти  URL-ки медленно отвечают,  и какие-то могут вообще отстрелить  с ошибкой. Так вот, я хочу, чтобы если какая-то URL могут вообще отстрелить с ошибкой.
(31:07)  Так вот я хочу, чтобы если какая-то  уралка отстрелилась с ошибкой, мы тут же закончили выполнение программы. Как бы там это доработать?  Ну, есть очень удобная штука, которую часто используют в коде, но которые нету в стандартных редакторах вот этих вот. Это, короче,  error-группа, вот,  и типа у нас бы просто гарантинка возвращала ошибку,  вот, и  в случае чего мы возвращаем ошибку,  и там при первой же ошибке сразу  все остальные гарантии завершаются.
(31:38)  Ну, хорошо.  Я думал,  а еще какие варианты есть?  Этот вариант классный. Да, еще варианты есть? Этот вариант классный  Да, еще варианты есть, короче  Тут  Ну это выглядит все обычно некрасиво  И, короче, тяжело  Прям сделать нормально  Ну у нас должен быть  Допустим, типа у нас там  По первой же попавшейся ошибке  То есть у нас там, ну, наверное  Какой-нибудь  Контекст должен быть Который бы отменялся в случае ошибки то есть у нас там ну наверно какой-нибудь контекст должен быть как который бы отменялся  случае ошибки все остальные гарантийные должны как на этот контекст завязаться то есть мы должны до
(32:13)  сетевого запроса проверять что у нас контекстом типа не отменен ли случайно там конь select с  дефолт секций вот и типа вот мы ну да тут принципе после запроса и после запроса тоже там чтобы там ничего не вывести  вот но тут такое типа начинается это или бы ну конечно много способов либо нужно как-то на конте атомик завязаться там  какой-нибудь булл типа что у нас там была ли ошибка или нет вот плюс еще саму ошибку если мы хотим где-то вне  этих гарутин получить там типа в канал и написать  как бы типа способов много, вот.
(32:46)  Но обычно просто error-группой делается и всё.  Угу. Хорошо.  Ну, сделай так, как тебе  больше нравится.  Окей. Ну тут, насколько, короче, о этих редакторах я знаю,  тут нет error-группы, потому что это типа не стандартный такой пакет, там что-то...  Ну, ничего страшного.  Даже если забудешь сигнатуру так что я не помню  я понимаю что в реальной жизни тебя поедаешь кгрупп ну и соответственно здесь вот мы оставьте по герб групп  что не помните сюда мы короче передаем это нашу функцию  которую то ошибку возвращает вот сюда мы пишем вот это вот так и го плечо такое тут насколько
(33:56)  я пункта го и тут мы верить и по если у нас ошибка не равно, тогда мы эту самую ошибку возвращаем. Если что, тут типа return new.  Ну и типа вот здесь мы, ну смотря где мы хотим,  типа nokia-launched, и тут типа если что-то в ERR-группе какая-то ошибка и типа тогда вот мы там не знаю там что-нибудь  EROR короче выводим вот  ну не знаю можно написать fmt там println ER ну и все там типа завершаем.
(34:47)  Ну вот, что-то типа такого.  Хорошо.  Проверить сам не могу, потому что точно не помню все сигнатуры.  Корее все корректно вроде?  Да.  А второй вариант,  который я намекал через контекст на самом деле.  То есть, можно сказать, что такое контекст?  Да, ну, контекст, то есть там, по сути, настройка над каналчиком.
(35:17)  Контекст у нас используется вообще для того, чтобы...  Обычно он должен использоваться для того чтобы типа у  нас там и приложения у него там несколько уровней там у нас разные там  какие-то компоненты в приложении там http сервер там еще какой сервер всякие  запросы и мы с помощью вот этого наследования контекстов можем его так  уделить на слои потом еще какие-то сайтам выключать отмены контекста ну и  там типа завязаны на него  там чтобы греху что да он делать но обычно просто делать контекст бы грантом в моей не короче он
(35:51)  везде пара прокидывается просто а помимо контент до гранта какие еще там с отмены типа висканцел  с назначением визуалью там с тайм-аут есть, с дедлайном. Отлично. А вот  визуал, что-то такое с удничком  стоит, это зачем?  Ну, короче, можно там значение передавать  в этом контексте.  На самом деле, очень редкий кейс,  и вот всегда, когда я с этим сталкивался, лучше было бы  просто не делать ничего,  передавать значение просто аргументом  функции, а не через контекст.
(36:24)  Ну, вот можно там, типа,нибудь логер в него запихнуть  и получать его.  Хорошо.  Коллеги, есть какие-то еще вопросы?  У меня вопросов нет,  у меня есть замечание, я все-таки сверился с докой,  и там сигнатура немножко другая,  но это несущественное замечание.  Так, чтобы все были в курсе и все заново вспомнили, как работает сигнатура эрор-группы.
(36:53)  Погнали дальше.  Отлично.  Пошли дальше.  Так, следующая задачка. А?  Вот такой код.  Что у нас тут будет выведено?  Так, ритм.  Как она вообще будет работать?  Так, окей, у нас есть какая-то мапа.  Ага.  Так, мы дел, у нас есть какая-то мапа. Так, мы делаем read.  Что тут в цикле? Ага, и write.  Ну, запустится read, и вот пока секунду в write не запустится, мы будем читать.
(37:38)  Потом запустится в write, ну и, короче, у нас пойдёт...  Ну, вообще там, насколько я помню, просто с ошибкой программу пойдет там типа конкарант  играет там там об такое ну в любом случае тут на по типе не обложены там не битоксом ничего и там  писать читать не не очень ну короче нельзя конкурентно безопасно вот ну как он тут горка  прямо отслеживает вот так в таком простом случае не просто упадем с ошибкой короче там она не  всегда стреливает короче на 1 секунду мы поживем пока мы читаем потом короче там
(38:17)  насколько помню чтобы попала вот прям вот вот вот по-настоящему чтобы мы  променяли момента брать обратилисьились к мапе, и тогда он  задетектит. Но в целом этого может не произойти.  Ага.  А вот если ты подозреваешь,  что ты такой косяк сделал,  можно...  Есть какой-то способ точно  поймать такую проблемную ситуацию?  Ну,  есть типа флажок, там вот этот рейс,  можем с ним запустить.
(38:46)  Ага, да, именно. флажок, там, вот этот рейс, можем с ним запустить. Ага, да, именно.  А если мы возьмем, например, на 25 строке не А, а П, читать?  Пойдем?  Да, да, ну, все равно, типа, рассматривает мапу как, ну, типа, цельный там объект, вот, поэтому... Ну, и память ее.  Короче, насколько я понимаю, понимаю да все равно должен упасть хорошо давай  как-нибудь подлечим ну можно типа синт мапой но обычно не очень все мы можем битых сделать ну  по сути чего у нас тут тоже в какой-то глобальной области видимости он должен быть
(39:27)  там, что там, sync у нас  sync  ну хотя можно rw mutex, типа ну тут, ладно, rw mutex  вот  вот ты запускаем так как я и ну типа каждый раз мы хотим прочитать мы там типа получимся и так и тут у нас чтение получается мы получим финально чтение ну и  разлучимся тут на запись поэтому просто лучшимся короче капитально  хорошо а вот помимо что сначала просто не это мьютекс потом? А в чем у них разница? Зачем придумали разновидность какую-то?  Да, ну, короче, если обычный мьютекс мы используем, то мы просто какие-то секции
(40:34)  лочим полностью, и нам там не важно чтение, запись, просто лочим. И поэтому у нас...  Почему вообще мьютекс придумали? Потому что какие-то умные люди заметили, что мы писать в какие-то разделяемые ресурсы  безопасно не можем,  а читать конкурентно мы можем.  И поэтому зачем нам тогда на чтении все лочить,  если мы можем конкурентно читать все-таки.
(41:00)  Поэтому RvMutex у нас появился.  Как он работает?  То есть мы когда лочимся на  чтение, то  все там другие гарутины, которые придут и возьмут  лог на чтение, они как бы тоже смогут  его взять и не  ну, не остановятся, то есть  у нас мы будем конкуренты читать.  Вот, но как только какая-то гарутина придет, захочет взять  лог на запись, то мы подождем,  пока все прочитают и  возьмем лог на запись. И вот пока мы будем писать, если кто-то в этот момент захочет прочитать, то он тоже будет ждать, короче, пока мы подождем пока все прочитают и возьмем блок на запись и вот пока мы будем писать
(41:26)  если кто-то в этот момент захочет прочитать он тоже будет ждать пока мы это пишем но в итоге у  нас типа гораздо быстрее происходит операция чтения вот и статус уходишь мы там много из хорошо а ты еще упомянул симпман отчеты захотел использовать потому что там он вот это и не  хранит и короче с этим неудобно работать на самом деле вот потому что там это нужно постоянно  приводить типы вот в этом получаешь не круто в данном случае может было бы этого типа синт-мапа потому что мы тут ничего не делаем со
(42:07)  значениями как бы то есть мы могли бы при println как бы и вот это и не писать она все вывелась но  типа есть там что потом уже было делать с этими данными это очень удобно а какого случая ты все  сказал мне вот здесь и максимум а я чё-то короче читала врачи на самом деле не видел ни разу в вроде синтмапу но читал зачем когда используется  что-то на какие-то значениях на счета там как-то начинает там какой-то кэш свою горячую холодную  map и короче обнигай но на самом деле при очень сильной конкурентности она она будет эффективнее заоптимизировали то есть это будет
(42:50)  эффективнее чем самому сделать мапы обладать и так ты сделать супер оптимально хорошо а Хорошо, а ладно, вот тут mutex, sync maps, примитивные синхронизации какие-то ещё, знаю.  Да, ну вот ER-группа тоже, можно считать, wait-группа, ну, Atomica, ну чё там у нас ещё?  Вот, mutex и Atomica, ну короче, да, первое, что было, пришло.
(43:21)  Может ещё какие-то там из пакета sync? есть уанс я помню вот типа что у нас там мы вот этот блок кода только один раз запустим  вот ну чё там еще есть короче отберет пера чисто на сет на потомике mutex и вот синкванс в группы все больше не спал но они уже реже используются согласен так коллеги может еще вопрос какие-то у меня нету для мапы какие ключи можно Массив можно сказать? Хороший вопрос.
(44:28)  Блин.  Я вот знаю, что там какой-нибудь канал мы там  или контекст мы там не можем  использовать. Вот, массив.  Блин, ну массивы там...  Блин.  Я никогда  не сравнивал, блин, массивы.  Не доводилось. Но если равно-равно между ними работает, и оно компилируется, тогда можем.  На самом деле, знаешь, ещё канал можно использовать. Канал можно между собой сравнить.
(44:58)  Ну ладно.  Да, можно дальше. хорошо так а вообще можно сказать как мапу что может коврился мапа хаш типа хэш таблица у нас  там все как бы ключи которым передаем этом кашируется ну и дальше вот это стандартный  флоу вот этой хэштаблица то что  типа у нас там есть вот хэш функция дачи с которым получаем хэш сам хэш и дам типа то  где находится там нужным бакет в этот бакет мы там короче кладем значение там в одном бакете  что до 8 значений может быть если мы там больше 8 значений у нас получается, то мы еще один короче бакет уже делаем и
(45:47)  рано или поздно нам придется делать, ну типа пересобирать  данные, это называется эвакуация данных, чтобы мы в один момент не получили там OATN доступ.  Хорошо. Главное, я уже следующую задачку сам рисовал, скажи, что будет в эфире.  Так, канал Я уже следующую задачку сам рисовал. Скажи, что будет выявлено.
(46:08)  Так, канал интовый.  Сразу пускаем гаррутину.  Что-то пишем.  Time sleep.  И закрываем его.  Окей, что-то записали.  Мы подождали, пока гаррутина запустится.  Она, скорее всего, тут запустится. И запишется, после чего мы закрываем его, короче, сразу.  Вот, но канал у нас не буферизированный, типа, поэтому мы его закрыли, сюда мы даже ничего не увидим тут, потому что он закрытый у нас.
(46:39)  А вот этот for range, он работает, типа, до того, как канал не будет закрыт. все закрыт канал ничего не выйдет у нас просто запустить слить паника тогда объясню почему паника а блин ну короче понятно  ну потому что мы писали закрытый канал я что вообще совсем забыл как и неыл, как и не буферизированный канал там под капотом работает.
(47:28)  Я почему-то подумал, что типа вот тут вот мы типа запишем, и все, короче.  А там же, да, буфера нет, поэтому мы тут будем лоджиться, ждать.  А тут он вдруг закроется, и у нас записи закрытый канал. Ну да, паника.  Да, совершенно верно.  Давай как-нибудь поправим.  Так, ну окей.  А что мы хотим получить? Единичку писать и...
(47:59)  Ну да.  Окей.  Да, да. Идея в этом была.  Ну, тогда обычно закрывает тот кто пишет тут мы будем закрывать то есть мы  тут запускаем какие там слепо нам нужны и тут там ченьки фонтан там там вот то  есть мы запустим карутина тут будем ждать короче пока мне чуть запишу не запишут сразу увидимся канал закрывается  Так, коллеги, есть вопросы по этой задаче?  Нет, у меня тоже погнали дальше.
(49:04)  Так, что думаете?  По каналам еще или про интерфейс?  Да, давай по каналу вторую задачу.  Вторую задачу, да?  На мерч.  На мерч.  Давайте.  Так, вот у нас...  Вот такая вот изучить код могу пояснить да ну то есть здесь формируется так сурс он принимает какую-то функцию которая че-то рандомный не принимает канал у нас есть мы запускаем гарутину в конце мы канал закроем и мы 10 раз в этот канал  который мы пишем
(50:08)  запустили продюсеров  которые рандомно int пишут  потом еще раз запустили  которые не рандомно пишут  а от 0 до 9  и потом мы мердж ну я так понимаю так понимаю дать мы должны как бы результат канал  смерть так вы имеете доходных канала 1 1 требуется результата меж который будет сливать данные так ну она у нас вот этот out все мы возвращаем так ну ща прикину вот мы должны как будут по  всем каналам идти мы должны как бы но если мы их мерчим может лишь а типа синхронно их типа  замерзли там без запуска грутин вот но можете по ноте если нам нужно порядок сохранился вот если не нужно что порядок сходил сможем
(51:10)  грутин запустить нам нужно что порядок сохранился ну они же принципе не  обидеть так мы тогда запускаем грутину в которой мы будем в этом но тут такие c там  которые мы будем из этого канала который вот у насено мы будем писать в out вот ну типа так пошли по всем каналам мы  короче запустили грудь тинки и мы как бы из этого канала мы читаем из всех и пишем в аут когда у нас там типа этот закроется канал вот здесь вот то у нас гарутинка завершится так она  будет работать вот такого хорошо выходной канал что получится у нас
(52:21)  вечно открыто ну, тоже надо закрывать. Хотелось бы.  Что еще раз?  Да, хотелось бы закрыть.  Да, да, да.  Вечно.  Ну, тогда получается, нам нужно его закрыть,  когда мы в него все запишем. Ну, короче, понятно.  Можно вот такое финт ушами сделать.  Типа, вейвайт-группу,  вот эти все гарутинки на вейвутинг новой группу повесить и еще  одной отдельной гарутине ждать пока они все запишут и тогда закрывать out  так в группа 1 так мы запустили гарутинку тут сразу  видан и вот типа  так вот в отдельных и рутине мы будем типа ждать пока мы перестанем вообще читать писать и после
(53:31)  этого сделаем коз у меня почему-то мысль, что, типа, мы...  Так.  Ну, короче, выглядит как-то так,  но, типа, если мы запустим все эти гарантины,  вот эти вот... Вот эти вот...  А, ну всё. Ну да, всё.  Вот так вот оно выглядит.  Выглядит красиво.  Коллеги, есть ли вопросы?  Нет, нет, нет.
(54:38)  будет красиво коллеги если вопроса я тоже погнали дальше идем быстро но давайте тогда еще про интерфейсе ящики чуть-чуть поговорим расчет от быстро а вот такой код что вы видите на но это вот это сравнение  интерфейса с милым моим что-то фу который у у нас m4, у нас тут  типа ничего нет, возвращаем error,  который типа nil, но на самом деле  мы  выведем, упс.  Угу.  Ну, немножко поясни, почему.  Ну, интерфейс, насколько я помню,  это вообще типа он состоит из там  двух указателей, один это на  тип данных, второй это на сами данные на  сам объект и вот когда мы вот вот вот так вот возвращаем его то тут у нас указатель на тип  данных он определён что это типа маэр ну и все и теперь уже интерфейс не нил даже несмотря то
(55:17)  что именно объект указать на объект нил но указатель на тип данных не нил, поэтому у нас интерфейс уже не нил. Ага, ну да. Совершенно верно.  Запускаю, пишет Ops. Давай как-нибудь поправим  функцию foo, чтобы она  адекватнее. Так, ну да.  Фу, чтобы внешний коцик адекватнее на неё  реагировал. Угу.  Так, эээ...
(55:44)  Ща, кстати так ну так вот мы делать не будем тут типа с чем и тут если больше пяти тогда вот  этот рейтер моер так вот и error имплементирует именно не указатель а просто типа структура.  Хорошо.  Ладно, а вообще про интерфейсы. А для чего они  обычно используются?  Может быть что-нибудь там про dependency injections?  Да,  используются вообще для  полиморфизма,  чтобы у нас типа мы там могли  писать функции там или обрабатывать данные  без конкретных типов,  а там просто что там есть какие-то определенные
(56:31)  методы у нас. Ну, часто используется  там, типа, когда там  пишем микросервис, там, типа,  кстати, вот не понимаю, зачем, но всегда, короче, уровень  сториджа, он всегда вообще обкладывается интерфейсами,  хотя там всегда один сторидж, и, типа,  зачем. Ну, да, вот, типа, интерфейс  у нас просто  если у структуре с кита методы которые определены в интерфейсе то она его типа автоматически  имплементирует мы можем как бы ее использовать там где интерфейс пользуется вот продлит и  пенсии джекшн не скажу просто пусть не знаю там ну короче это это часть соли да вот в чем прикол я забыл короче да не скажу сейчас ты не
(57:11)  знаешь почему используется интерфейса для хранилища не я понимаю что типа там  вдруг мы там перейдем на новое хранилище и тогда еще какая-то другая причина есть, почему интерфейс используется.  Ты тесты сам видишь в работе?  Ну, типа мокнуть мы можем, да.  Ну, да,  конечно, да, бывает  случай, когда у нас там какая-то жесткая зависимость  кубернетиз-клиента,  и мы в юнит-тесте не можем его  поднимать.
(57:44)  Поэтому мы  используем интерфейс чтобы могли его  мокнуть вот это конечно да но просто обычно и так можно протестировать но вот теперь интерфейс  и везде шлюпаются на самом деле это основная причина почему надо использовать интерфейс это Для юнит-тестов написали, без них не можешь создавать юнит-тесты.  Согласен, да.
(58:07)  А ты тесты много писал?  Да, да, всякие разные книжные писал.  А как ты тестировал, ну, если там завеска, например, на слой хранения, на базу данных?  Или ты поднимал базу данных?  Не, не поднимал, ну типа  нет, ну короче, обычно вот  я  понимаю, что интерфейс это мокать  да, я имел ввиду, что обычно  ну типа у меня на практике я так сталкивался, что  юнит тестов то нету, ну типа  на уровень хранилища, но при этом  все интерфейсами обложено там 10 раз вот  так то понятное дело там типа если мне там нужно тест написать то я уже говорил да то что на интерфейс
(58:53)  переходе а приходилось чисто архитектуры икса гональник ну скорее сейчас не сталкивался об этом не на многослойные  нет в этих терминах много сны типа только гадать ну типа несколько слоев  там у нас уровень api и бизнес-логика стороны  ну типа самые такие вот большим обмазки разделение приложения слои это вот как сказал агапи стаж  бизнес-логика что это такое то есть уровень api это все что торчит на на на наружу это короче там  теперь gpc http там и брокеры то есть то как с  нашим вообще сервисом работать вот то есть как у функциональность мы
(59:50)  представляем наружу вот второй слой это уже бизнес логика это то что вызывается  ну слоем api и то что уже пользуется слоем  сторожа то есть мы какие-то данные перекладываем мы какие-то данные  получаем  и обратно на слоя пиками возвращаем он уже там типа клиента возвращает вот ну и уровень сториджа  это там собственно хранение данных там типа да там положить удалить хорошо а еще про интерфейс который который назвал как они до ничего нужен да ну и не это типа вот тот то самое  вот звездочка то есть это все подходит для чего нужен ну вот у нас на трюкам println мы хотим
(1:00:36)  уметь все принять на экран поэтому типа и не ну и не у него нету никаких методов, поэтому все имплементирует any. Вот, типа все подходит туда.  А вот прилетела нам какая-то any, хотим все-таки над ним и так type switch то есть типа как свечки есть только  мы можем вот интерфейс привести к конкретному типу и посмотреть как бы чё там за тип да еще  кроме кроме свечи какая есть конца до можно были над не пом, вроде через рефлекс как-то, ну, то, что мы можем то тоже, типа, конкретному типу попробовать привести, и там, типа, второй флажок этот, окей, то, что это тот тип или не тот тип.
(1:01:34)  Через рефлекс, совершенно согласен, это, наверное, третий даже способ.  Блин, да, больше, наверное, не назову такое, редкая тема, короче, забыл, что там вообще.  больше не назову такая редкая тема короче забыл что еще есть или можно перейти от базе я думаю можно пойти дальше отлично ну тогда передаю снафету  саша Саша, ты микрофон выключил.
(1:02:36)  Да, сорян.  Так, да, я вставил две таблички.  Первая табличка – это корзина,  вторая – это купатель.  Вот, они между собой связаны  по Customer ID колонки,  и, собственно говоря,  корзина – это то, что пользователь  добавил в процесс покупки.  Вот, и  нужно написать запрос, который выводит  всех пользователей  колонку ID и email  и все элементы  в корзине.
(1:03:11)  В одном списке.  Ну, типа, вывести пользователя  и его  корзины  из cool country, custom amount,  ну, типа, вывести всех пользователей с их корзинами сразу можем там у нас там join public cards он каста айди равно public так вот ты использовал джонда москась какой-то тип джон и мир и мар а как он работает но он  находит все пересечения которые тут задаю и выводит только те строки где вот он собственно нашел эти пересечения
(1:04:25)  допустим смотри есть нам надо было вывести всех пользователей даже у которых корзина  тогда лэп джоинда какие типа джоинов еще знаешь Ну есть, да, вот inner join, left-right и full join, насколько я помню.  А full как работает?  Full outer join.  Ну, full это типа вот у нас есть left join и есть right join,  а это он типа и left, короче, и из левой таблицы докидывает там строки,  которых не нашлось на пересечении, а потом еще и справа тоже докидывает.
(1:05:20)  Угу. которых не нашлось на пересечении а потом еще и справа тоже таки дают через пятую шел вот так вот какой-то джон будет это но это вот типа king in a joint будет но насколько я помню он там ну да ну короче ты на жизнь а вот возьми себя вот это вот у бюро да как уже будет работать  так ну типа более  не помню тут может указать надо короче выглядит так как будто это будет full full  join вот но так я очень давно не писал не меньше вообще запустится на самом деле ну  типа мы тут все как бы ну да просто короче не знаю только гадать из тогда еще такой вопрос. Допустим, нам надо вывести только те товары,
(1:06:07)  у которых брошенная, ну не брошенная корзина,  а допустим у нас ошибка в нашей таблице,  что появились записи в таблице карты,  у которых нет пользователей.  Как бы ты посоветовала бы вывести какие-то записи?  Нет пользователей, типа он там null. ты посоветовал бы вывести записи нет пользователь фондом нал ну то то что было только еще в добавить Так, давай тогда поговорим про индексы.
(1:06:49)  Какие индексы сам использовал?  И вот для ускорения, допустим, запроса,  ну, в данном случае по кастамер-1, например,  мы хотим целый запрос, да,  то есть какой тип индекса ты должен использовать? Так, ну, индексы... Чаще всего я использовал стандартный B3.  Все же не думал, что это binary 3, а оказалось, что это balance 3.
(1:07:13)  Есть у нас hash-индексы, gin-индексы для полнотекстового поиска.  Но я говорю, что это я часто не использовал. В основном это вот этот бэтбэк бэтриндекс вот  как он работает то есть и потом все данные он разбивает там виде дерева в ноде ключ это что  за данные а значение таких страницах памяти не лежат вот за счет это типа мы можем не перебирать  ту по все строки уже там заранее знать где где что лежит. Вот.
(1:07:46)  Есть у нас вот такой запрос,  типа, да, как я понял, вот такой. И мы хотим, ну, вот тут у нас, типа, сравнение происходит,  customer ID, так, индекс, индекс. Так, ну, типа, что нам мешает просто на колонку кастом ради накинуть индекс еще а вот какой  тип до битрича типа есть вот хэш и из которой у нас для сравнений но насколько я помню он  даже сравнениях типа медленнее чем b3 вот ну короче я бы b3 навесил чтобы нам хотя блин костюм рейди больше-меньше вряд ли будем  сравнить до битвы сейчас на повесилась а какие у них от минус да ну у нас когда таблица там
(1:08:39)  обновляется то индекс у нас пересобирается, потому что нам нужно новые данные перераспределить в графе,  в дереве.  А если у нас таблица часто обновляется,  то мы слишком часто будем  пересобирать индекс и можем  навредить только.  Допустим, у нас есть  большая-большая таблица,  и мы  новый индекс по колонке  добавляем.
(1:09:15)  Какие проблемы могут быть в продаже на табличка там пара пара байт данного вот и ты на колонку вешу x ну кроме то что назвал что типа вот она дайте чаще но вообще типа индексы но много весят  мы-то можем вне внезапно все память кушать индексом индекс на вешаешь там от капота табличка что происходит я много мы к ней доступа не был на момент навешивания  сразу точно не знаю ну типа логично предположить что она залощится вот на время создания индекса  а есть какие то есть какой-то способ этого избежать альтернативный способ создания на
(1:10:08)  колонку на большой таблице не знаю  так давай тогда ко второй таблице те же самые условия как бы примерно такой же структур  таблицы такая же но формулировка она немножко другая задача нам нужно вывести топ-10 клиентов по количеству товаров в корзине.  То есть имеется в виду, нам не важно, какой товар,  нам важно понимать, сколько всего мы добавили товаров,  не важно, какие.
(1:10:56)  Так, топ-10 клиентов по количеству элементов в корзине.  Ну, типа, у нас есть табаблиц то есть мы хотим понятно ну  короче как я понял типа нужно сделать запрос сгруппировать по кастом ради там  типа сложить и mount и сортировать в обратном порядке взять этот лимит 10.  Клиентов еще хотим, понятно, там public cards, join public cards.
(1:11:50)  Customer ID.  Public Customer ID.  Так, после этого мы хотим сгруппировать cards ну кастом ради так и типа суммы mount thereby сумм блин давно и на скале не писал так сумма mount дискинзинг и типа костюм ради грубо сумма дискинзинг на блине 10 и тут короче просто. не  можем вывести мы групп группируем по Customer ID.
(1:12:49)  Как-то, короче, надо вывести, ну, типа,  саму Customer ID мы можем.  Так, нужно еще email этого пользователя вывести.  Ну,  блин, я забыл, короче, будет он ругаться или нет если я просто увидю и мы но если будет то  дастами рейди вот но если будет короче тут ругаться что там что-то мы не сгруппировали по этому полю то можно вот тут вот так вот через запятую еще его добавить  так а вот есть допустим тебя есть задача такая вывести всех клиентов независимо если у них там корзин чем тюрьму мой запрос он как бы удовлетворяет
(1:13:49)  ну типа  1 0 до ничего не добавлял табличка костюмер есть корзин чем добавлю а во второго  что то есть да то есть получается вот этот запрос она выйдет только одного человека  которого что то есть ну типа если вы в принципе нет вот в этой таблице дата его не выведется ну типа опять же можем по public  cards вот тут уже райт join кастомер тогда у нас типа подсоединяться кастомеры даже которых не  будет в этой таблице может но вместо райт о чем рассказ? Write допустим мы не хотим, да?  Так, ну вот на этом моменте мы уже типа теряем всех пользователей, которых нету вот в этой таблице.
(1:14:58)  Вот. Смотри, это получается  карты присоединяешь кастомерам.  Может быть,  эта формулировка наведет  на определенные мысли,  что что-то может по-другому  попробовать то есть а левой  таблице от карц что если мы левой таблице сделал каст ну если мы просто  типа их поменяем че не изменится пшена дар join мы можем ее сделать слева и сделать смотря допустим если у нас у двоих  кастомеров будет одинаковое количество суммы как они каком порядке не исполнилось может быть как-то этот порядок будет зависит  типа по порядка добавления в таблицу изначально там что типа мы за джойнинг там и короче для нас
(1:16:18)  это я просто случайный порядок не будем же мы там в про смотреть там чё где на какой строчке у нас  запись а я есть попросили по порядку из ну смотря какому порядку типа по какому полю хотим  сортировать так а вот что если еще дополнительные условия добавить в эту задачу нам допустим можно получить только тех кастомер в которых корзине больше остаток  больше 100.
(1:17:12)  Допустим,  если мы навесили индекс,  то есть вот знаешь, что такое составный индекс?  Да, типа, когда  один индекс сразу на несколько столбцов.  Там какие есть правила, когда этот индекс будет использоваться?  Да.  Ой, там, короче, честно подзабыл, там какое-то выпендрежное правило,  что там все столбцы, которые на равно, они будут использоваться,  и первый, который на какое-то неравенство,  на больше-меньше.
(1:17:48)  А все, которые правее, они будут.  Ну, там, короче, такие танцы с бубном.  Вот у нас  индекс мы навесили на  колонку,  допустим, Customer ID,  Country, и там скаю да таки три колонки вот допустим если мы  берем то есть запросить не будет участвовать в этом кастомер айди да то будет ли у нас  но он при сравнении используется ну скорее всего он типа вот на и надо на джойне тоже  она будет составной так вот там внутри такой и в запросе у нас не нет фильтрации по кастомерам тендекс будет использоваться не помню но вроде нет но
(1:18:48)  не знаю короче а если знаешь что как бы ты мог это не хочется паук ну как загуглил бы в интернете в  каком порядке вот по факту ну да и парнотестов печень ну на деле можно там X-Plane посмотреть. X-Plane Analyze.  И там посмотрим, что вообще используется и не используется.  А вот, допустим, у нас есть  индекс по колонке кантра.
(1:19:15)  Всегда ли он будет  применяться?  Какая характеристика  используется при  анализе применения индекса?  У нас составной индекс или просто вот на кантри мы это повесили индекс до думали что она как-то ускорит запрос но типа  всегда ли будет применяться меняться индекс по колонке  то есть чем руководствуется планировщик запрос на заказа  строит план запасной на мази надо ли на спинке  ладно вопрос на спас подвохом я опять скажу не знаю типа я бы предположил что титул блин там индекс повесили как бы все он типа должен использоваться но есть такая формировка
(1:20:19)  вопроса короче наверно не всегда используется ну не знаю слышит такая штука селективность а ну в планировщик  он же не смотрит там селективными не селективно сколько я знаю просто будет использовать уже на  как я насколько знаю и уже как бы понять вообще селективная вот эта колонка или нет чтоб там на  гендер там не кинуть индекс то есть ты хочешь сказать что у тебя вот то на  весь линдекс и он вообще не смотрит на статистику никакого до используют  так заработал с есть вопросов по первым задачам вопрос умение просто вопрос а если сталкивался если я запросил это хочу
(1:21:11)  еще в каждой строчке вывести список из краюшек как бы это так попробуй точно должно выглядеть анти по строке еще как короче насколько  помню хотим что еще сюда добавить нам нужно поэтому сгруппировать еще просто  еще поиск ушкам но блин не знаю все уже короче я поплыл скию хотим вывести но это уже не совсем  стандартной сколько на вкус гус джейсон в общем у каких-то  ребята с арей джейсонами с конкуренцией  на что такое может вопрос не применял ли ты командой блок спрашивать тогда у нас поиск или вот последний час быть задачку и может быть если останется время там еще кольки опросики сдаем так у нас есть
(1:23:01)  такая простая табличка отражающая как бы какое-то приложение где есть пользователи у нас есть такая простая табличка, отражающая какое-то приложение,  где есть пользователи,  у них есть баланс.  Будем называть банковское приложение.  Есть функция, на псевдокоде написана,  которая делает списание денег  с баланса пользователей.
(1:23:22)  Предположим, что у нас реально какая-то такая среда,  когда у нас конкурентное выполнение, то продакшн система и чтобы ты здесь посмотрев на эту функцию мог бы заметить какие-то проблемы посмотреть, подумать, рассказать. Так, ну окей.  Так, функция,  что-то там.  Select, баланс,  рум-юзер.  Ну,  типа, у нас  тут вот это все неатомарно  происходит, поэтому  поэтому, короче,  все вытекающие отсюда.
(1:24:06)  Мы тут получили баланс,  тут  update set balance,  balance-1.  Мы получили баланс, а в  другом потоке исполнения  мы его обновили, но тут  мы его все еще считаем старым,  поэтому неправильно будут  списания у нас происходить.  Окей. это одна проблема вот может раскидать вот какая ситуация может получиться как это на балансе Так, ну сейчас я тут балл... Типа, сток-то списать, окей.
(1:24:50)  Ну, типа, мы там пользователь,  хотя он один и тот же,  ну, короче, типа,  два раза что-то купит,  вот, но при этом  спишется у него только какая-нибудь  одна вот эта вот из покупок,  а вторая просто потеряется. Ну, это как этот, что там?  Ой, забыл,  как аномалия по-умному называется.  Там какой-нибудь Lost Update, что-нибудь такое.  То, что типа, ну да,  мы  спишем один раз, там минус 50 рублей,  минус 100 рублей, но тут вот будет  баланс старый, поэтому там только что-нибудь  одно из этого останется.
(1:25:23)  Может ли  отрицательный баланс ну да может анализ вот мы получили баланс тут мы считаем что он типа у нас окей но в  этот момент кто-то нам сделал меньше но тут там и все еще старый баланс как бы думаем что он про старый поэтому значение  типа два раза не спишется вот то есть отрицательному может быть полос сейчас сейчас скажу так баланс  блин уже сложно конечно сама смотреть на на это все ну король ну блин да ну давай просто не спеша да просто подум, как может получиться в такой программе отрицательный баланс.
(1:26:28)  У меня маленькое предложение.  Может быть, дадим перерывчик на несколько минут?  Потому что действительно тяжело.  Не, можно не торопиться.  Можешь подумать, мы не торопим.  Подумай, посмотри, как отрицательный баланс такой программе  получили в 1 у нас больше бы 0  ну это блин я тупо ну я думал что вот тут баланс который там используется он как как тот переменный зависит на переменную  зависит вот поэтому типа ну да мы вот там в двух параллельных там трейдер взяли баланс в  двух параллельных трейдер он там был больше ну типа нам хватало денег и мы типа два раза списали
(1:27:20)  его тут два раза спешится дай быть помечтали у нас 60 рублей там типа у нас там  две покупки по 50 рублей они такие ну да ну будет больше 0 и два раза спешится по 50 рублей  может еще какие-то так есть повнимательнее посмотреть да да какие проблемы с гонками она существует но еще как минимум 2 может я могу сказать даже две проблемы ну то что у нас  деньги во флотах дошла на панике а вот ты бы в какой вариант предложил и способ к по правильному  делать с деньгами ну тут смотря что за система что у нас за система. Типа, если у нас там...
(1:28:07)  Она рассчитана на то, что мы будем там и в рублях, и в долларах, короче,  там еще в чем-нибудь еще оперировать.  Там вообще какие-то надо сложные уже структуры писать.  Но если у нас, допустим, просто рубли,  ну, там самое простое это в копейках считать.  Так, и вот еще одна проблемка.  Может быть, ты ее тоже заметишь.
(1:28:28)  так и вот еще одна проблемка может быть и это же замуч  так руки еще да она не связана вот вниз с гонками не с деньгами  это правильно но еще одна проблема это уже такая логическая ошибка  если у нас условие не выполняется то мы ничего не возвращаем типа итог  посчитаем у нас все до к, что мы ничего не сделали.  Функция, которая ничего не делает и ничего не зачем.
(1:29:11)  А смотри, на седьмой строчке  тебя ничего там не смущает?  Может быть, в самом запросе?  Ну, типа  user u,  но мы user id не передаем сайт баланс юзер айди как бы да не передаем  меняем баланс у всех пользуется что неправильно так вот смотри допустим мы хотим написать откат нормально какие варианты  ну транзакции использовать так но может-то там хотим сделать балансом осваиваем ее так защитить  ну если у нас единственное взаимодействие с баской в этой функции туда если не честно то нет не
(1:30:29)  защитит допустим тебя низко сервис так ну транзакция там чё там типа там т.к. забыл тут на самом деле можно писать как бы просто чем же псевдокодом можно писать начали транзакцию ну блин конечно вот так вот написала все  че че там commit а ну хотя она блин ну там зависит от вообще от драйвера  чего мы используем поэтому ладно да давайте никак не зайдем  а так пусть у нас здесь пасгре да так ну все тут начинаем транзакцию короче все по сути  все по сути так получили баланс так получили баланс смотрим что если на больше 0 и так нам типа теперь нужно либо за комитет либо rollback по сути select мы нам не надо rollback только только если апдейт но тут есть какая-то ошибка произойдет он его типа сам роллбэк нет но ну да
(1:31:49)  ну типа только будто довольно просто ну типа все над начали там и за комитете куча ну тут понятно  да мы можем сюда попасть поэтому при рюрных z так запомнил  смотреть проблемы решится  проблемы ну давай просто сосредоточимся на проблеме к крем-то изменение баланс  уйдет благодаря вот эту машину  ну типа смотря какой изоляции мы повесим вот про дефолтным уровнем изоляции какой  у нас дефолтный кстати в пастгре это read committed вот то есть мы будем видеть не ну  типа при дефолтном нет как бы короче при дефолтном мы в этих транзакциях типа возьмем изначально вот у нас от балансом будет
(1:33:08)  короче одинаковый на допустим там две покупки у нас ну тут вот как раз да мы типа сможем два раза купить короче отчет когда уж не хватает  принцип правильского давай еще какой-то вариант рассмотрим не менее уровень  изоляции чтобы еще может был на темы до чтобы заработал  так не меняю изоляции чего еще нужно было бы накинуть это заработало не знаю да я тебя на виду просто попал на посмотреть может понимаем наш у нас мы не  хотим чтобы с одного и того же пользователя  так вот небезопасно.
(1:34:08)  Это там предлагал Mutex.  Может быть, в базе есть аналогичные примитивы синхронизации,  которые мы могли бы воспользоваться.  Нам именно так, как мы шарим BD,  то мы Mutex не можем использовать, мы можем использовать блокировки.  Да, да, есть там типа вот это вот, мы можем там select for update взять, взять блокировку.
(1:34:36)  А не помнишь вот как его, где его надо писать в update?  Ой, не помню, не слышу сейчас.  Там в конце пишется  так кей да это один из вариантов то есть вот есть монолитен блокировку то мы защитим таким  образом у нас две транзакции они будут блокироваться первые взял блокировка а есть еще как это допустим да это там предложила с уровнем  изоляции давай начали наш поговорим о какие есть уровень изоляции какие проблемы не общаются committed, repeatable read и serialized был.
(1:35:25)  Вот, типа read committed у нас, то есть мы увидим изменения  там совершенные на другой транзакции только после  того, как она их закоммитит.  Вот, repeatable read это мы, там насколько я помню в начале  делается типа слепок там таблицы, там snapshot, его работаем там все другие транзакции комитет не  комитет на там все равно не увидим вот ну и сериала изобил это вообще там насколько я  помню просто последовательно как бы все транзакции выполняются смотрел 3 пик репика было рид к общам  то есть но зачем вообще сделали то есть какая есть проблема которая иногда
(1:36:08)  возникает который вот как-то решить как это называется есть такое слово  аномалия так ну типа что у нас там может на редко микс происходить то есть мы ой блин все эти названия на мали еще название название уровня изоляции она как бы  повторяющиеся чтение перевод... Ну, давай я расскажу неповторяющее  чтение.
(1:36:53)  То есть есть номера,  которая называется non-repeatable read.  И вот, может,  просто на примере,  как она проявляется.  Ну, вот сейчас, да, пытаюсь  вспомнить вообще.  Так, non- вспомнить вообще.  Так, non-repeatable read.  Так, ну получается, теперь проблема на read-committed у нас встречается.  Смотрел, допустим,  мы на седьмой строчке  баланс прочитали, да,  а у нас уровень изоляции  read-committed, да,  у нас здесь есть проблема не повторяющийся  давайте минусе метан поставим просто еще но смотри если мы в двух транзакциях два
(1:37:42)  раза баланс почитаем точнее если в этой транзакции мы еще раз баланс  прочитаем и кто-то в середине его поменял разную визу значения или одну тоже при перед комитет  как но тут-то мы его тело переменную запоминаем один раз, поэтому кто там чего поменяет. Мы еще раз хотим его  как-то прочитать, да?  Вот.
(1:38:10)  Вот между  двумя этими  вызовами  у нас будет одинаковое значение?  Нет, нет. То есть если кто-то закоммитит,  у нас типа read-commit, то у нас  другое значение будет.  Да, вот как раз пример неповторяющейся  сцены, что в рамках одной транзакции мы видим разное значение когда кто-то меняет тогда repeat албаритом  как ситуация ну как вот я сказал у нас там типа snapshot делается и поэтому мы  как бы несмотря на то что он тут чисто меня-то поменял, мы все равно одни и те же данные будем получать.
(1:38:48)  Смотря, вот как вот, ну, может, я понимаю,  что это, может быть, ты  не сталкивался прямо  до такой степени, но вот как вот repeatable  read работает? То есть он  на блокировках реализован  или на каких-то других  механизмах?  Нет, типа, если блокировка это уже какой-то села из-за был как будто срелась был использует блокировки я не знаю сейчас еще на подкапотом используют потом использовать так окей ну то есть вот смотри мы получается вот эту проблему с начальную мы  можем учиться так как еще уровень изоляции как он предложил уровень заряд
(1:39:39)  так говорит комитет разобрались что тут будет аномалия вот типа если мы возьмем и  репетибельный то в целом у нас вот этот вот lost апдейт может случиться насколько я помню  типа то что мы в одной транзакции там списали баланс ну а во второй то у нас вот этот снэпшот, поэтому мы не увидим это списание.
(1:40:08)  И опять, короче, придется, типа,  ну, одно списание потеряется.  Ну, сериалайз, сериалайз. На самом деле, давайте просто поправлю,  что lost update тут, ну,  lost update от потери на обновление,  дефолтный уровень изоляции,  read commit, это он защищает от loss апдейтов.  То есть вот такая вот  
(1:40:28) тамарная... На самом деле вот это тамарно  происходит.  То есть у тебя делается блокировка  на момент  изменения. То есть у тебя не может  так быть, что кто-то перепишет  результат другой  транзакции.  Ну да, но я про  repeatable read.  Repeatable read, он ну да но я про этот репетабл рид репетабл рид он типа да он на самом деле в позгарсе его можно здесь применять потому что он практически работает как сервалайзбу на других бтшках  у него больше уровня гарантий так скажем вот и что будет смотрел допустим есть мой repeatable  read поставили да и кто-то у нас поменял баланс да ладно я уже может типа не прав но вот насколько
(1:41:21)  я помню вот у нас есть repeatable read мы делаем вначале snapshot в каждой транзакции вот  мы в одной транзакции сделали апдейт а во второй транзакции типа этого апдейта мы не увидим вот  сделаем еще раз апдейт и типа поэтому у нас только не разбаланс пишется но может какие-то блокировки  короче не знаю типа возможно если мы там в двух транзакциях захотим там одно и то же один  тоже стал без поменять то они там типа за залочится короче не дадут  так а вот смотри может быть что есть я скажу что есть еще один вариант как это
(1:42:00)  все поправить это используя один запас как бы ты переписал от отцов артенку один запас  короче не знаю опять сейчас только что предполагает придется возможно это все  можете повод в одну функцию скелет запихнуть я не знаю какая как они там исполняются возможно там типа атомарно типа  она будет выполняться вся функция но как-то прям и на в один запрос типа искренний с апдейтом я не  знаю как это вообще можно сделать или субсидии да подумал просто смотрел на 103 операции  первое мы берем текущий баланс проверяемого на какой-то условия что там вот басни потом
(1:42:57)  мы делаем update и потом должны возвратить текущий баланс, который у нас получился. Как думаешь, как вот эти три вещи можно просто в один апдейт вернуть?  Типа апдейт вот там у такого-то юзера, where balance там больше amount. Ну и как-то вернуть еще надо блин там можно там ретернув из  такой штук в паз гре мы можем вернуть текущие значение баланс  но кей даем пора писать любом.
(1:43:46)  В целом, правильно сказал, что можно в апдейте проверить  вот это вот  условие, да, where  balance  ну, как бы amount  туда тоже передать, да,  вот, качество параметра.  User ID  тоже не забыть, да,  вот это вот условие.  Ну и, собственно,  как бы это, вот эта первая строчка  нам вообще не нужна, потому что  мы просто атомарно меняем баланс,  да, за счет  дефолтного уровня изоляции, редкоммит.
(1:44:16)  У нас здесь никаких вот этих проблем  не будет.  Потерянных обновлений не будет.  Значит, как бы  отрицательного баланса не может у нас все это  исполнится  ребят вас есть вопросы по вопросов можно было было было бы но у нас уже время  подоспела от сми досталось давай так далее они твои вопросы  к нам пожалуйста какие хочешь задавать давай да у нас такая практика но не не везде так но  мы рассказываем обычно про компании до руки есть у всех по-разному, на самом деле. Все по-разному.
(1:45:08)  Спасибо, что все, мне кажется,  было здорово.  Тогда мы расскажем  про компанию,  как у нас устроена команда,  как вообще разработка ведется,  инструменты.  То есть у нас  много команд, которые работают над своей областью был называть  домен с не при отдам ян заказов домен там лояльности домен праздника поиска их ну на  самом деле больше я самый такие основные то есть коман, она состоит как минимум из бэкэнд-разработчиков, тестировщиков.
(1:45:50)  Их количество может зависеть от сложности, области знаний.  Есть продакт-менеджер, который отвечает за развитие этого направления.  Обычно у нас квартальное планирование  используется.  Мы раз в квартал ставим все цели,  называется OCR,  Objective and Results.  То есть у нас есть  много какой-то бэклог,  продуктовых фич, которые мы  должны в квартал  попробовать подсократить количество  и загнать в рамки трех месяцев.
(1:46:28)  То есть мы отрезаем все, что считаем, что можно отложить,  берем то, что хотим сейчас взять,  оцениваем это приблизительно до начала квартала.  Потом, когда мы начинаем с квартала,  мы вот эти фичи уже более стально декомпозируем на задачи, помещаем в бэклог.  И, соответственно, потом эта задача распределяется по разработчикам.
(1:46:58)  У нас нет такого жесткого, допустим, привязки к анбану или к waterfall, к agile.  привязка комбана или там вот афон каким-то саджа зависит от команды какой стиль так сказать управление больше подходят к мы чаще мне кажется используется команда у нас есть вот эти задачи  на квартал да они постепенно помещается в бокок по мере так сказать разгребание вот и закрепляется  каким-то разработчиками вот обычно разработка происходит стандартный схеме то есть создается  фича ветка мы для task tracking используем jira для хранения кода используется GitBucket, но мы находимся
(1:47:47)  в процессе переезда в GitLab.  Вот.  Ну, фичи ветка, допустим,  все, разработчик завершил разработку,  тестировщик проверил задачу,  а дальше у нас  есть Kubernetes  кластер, в который все наши сервисы скручиваются.  Мы делаем релиз с помощью CSED,  она называется Bamboo.  Это решение тоже от Lassen, разработчика Jira.
(1:48:17)  Мы также, скорее всего, в ближайшее время перейдем на GitLab.  У нас будет единая CSED-основная GitLab. будет один сельский основной но собственно делом релиз катит катим все это на продакшн  смотрим обязательно метрики после релиза у нас есть пролетheus, Grafana, есть система алертов.  То есть если у нас вдруг какая-то проблема,  то мы можем от релиза сразу же откатить.
(1:48:58)  В целом есть кратко, как мы ведем разработку.  Наверное, еще коснусь немножко инструментария.  У нас в большей степениепени того как язык разработки иногда бы встречается по хп и питом и все меньше и меньше становится то есть мы активно стараемся  использовать то есть новый сервис и дает прям стандартного только в качестве бдс ки у нас обычно пас горе то есть есть церемонам парадис для каши  ранее допустим я сам работа в команде поиска у нас пользуется ластикч не популярна остальное компания решение именно плане поиска сна приметь у нас
(1:49:51)  есть своя свои внутренние инструменты разработчиков 1 это ночью у нас на самом  деле по большей части микросервера сообщается между собой по HCP, не по GFPC.  Возможно,  мы в какой-то момент будем  переходить на GFPC, просто пока  прям супер такой необходимости  в этом нет.  Поэтому у нас  большая часть взаимодействия  на HCP.
(1:50:24)  Кавка тоже активно используется для event драйва какого-то взаимодействия мы на нем  на самом деле не строим рпс на карте я не видел примеров где это чисто как ивент, ну, там, соурсинг, да, такие вещи.  То есть у нас есть своя шина общая,  да, в которой микросервисы как подписываются на эти события,  да, и могут, соответственно,  их как-то по-своему обрабатывать.
(1:50:57)  Вот.  Тул, вот про который я начала  говорить, он  нужен для того, чтобы... Вот у нас есть  у каждого сервиса Swagger специ спецификация стандарт это использование  swagger мы описываем айпишку вот нам нужно как раз генерить из нее код мы не хотим от руками писать  где это у нас есть кода генератор позволяет взять вот эту спинку в ямале да и на основе не изгибе  лить до до трансформа свой год получается код сервера и код клиента  можно также через нас генерить этот он закрыт это сегодня не сарси он также
(1:51:44)  активно сейчас трансформируется.  Возможно, мы перейдем на открытое решение для генерации.  Пока это, ну, как бета такая версия,  то есть текущий генератор, он также остается.  Мы его активно используем.  Также у нас есть генератор структурами крисе раз и более поинты  ступайка когда мы сами руками не пишем для новых сервис мы запускаем эту штуку  она нам генерит код и мы уже там бизнес-лайк начну на веку и у нас еще  есть тоже фрайвер для тестированияания помимо unit-тестов разработчики и тестировщики
(1:52:29)  по большей степени тестировщики они пишут функциональные тесты это когда микросервис  мы тестируем контракт у нас есть эта ручка endpoint и нам важно понимать что этот контракт соблюден то есть мы на него подаем какой-то  запрос и он должен ответить ожидаемо все внешней зависимости не макируется внешний сервис он  предоставляется днем мог мы как бы заранее готовят какой-то ответ на запрос поднимается как бы рядом да на нее накатываться какие-то тестовые данные  фикстуры мы можем проверить даже что базе будет храниться после нашего
(1:53:16)  титула и потратить такой специальный tool он есть в бену гитхайбе ламода называется моды называются гонки вот я наверное на этом остановлюсь основной сказать может быть все  есть какие-то вопросы круто протестирование вообще конечно редко слышу сам кто то что  то больше винтов пишет национальный интеграционный, когда запускаешь сервис,  подаешь, блин, круто, круто.
(1:53:50)  Вопросы?  Да в целом  так подробно все рассказано.  Да нет, наверное, на самом деле  все понятно.  Если какие-то супер-вопросы будут,  если я вдруг до финалки дойду,  там уже я что-нибудь и поспрашиваю.  Но вероятность это очень высокая что я советую подготовиться какие-то вопросы которые даже неудобный вопрос который хотел задать можно задать  представителем команды на этом тогда предлагаю закончить. Спасибо еще раз, что уделил время.
(1:54:26)  Да, вам спасибо.  Спасибо за время, было классно.  Пока.  Да, хорошего дня.  Пока.
