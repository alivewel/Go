### Что такое интерфейс?

**Интерфейс** в языке Go — это специальный тип, который определяет набор сигнатур методов, но не содержит их реализацию. Интерфейсы позволяют описывать поведение типов, что делает код более гибким. 

#### Объявление интерфейса

Чтобы объявить интерфейс, используется ключевое слово `type`, затем указывается имя интерфейса и ключевое слово `interface`, после чего в фигурных скобках перечисляются сигнатуры методов, которые должны быть реализованы типами, удовлетворяющими этому интерфейсу. Например:

```go
type MyInterface interface {
	MyMethod()
}
```

### Встраивание интерфейсов
В Go интерфейсы поддерживает встраивание. Для этого нужно в объявлении нового интерфейса указать название какого-то другого интерфейса.

### [Значение интерфейса](https://go.dev/tour/methods/11)

Значение интерфейса можно рассматривать как кортеж из значения и конкретного типа:

`(value, type)`

Значение интерфейса содержит значение определенного базового конкретного типа.

Вызов метода для значения интерфейса выполняет метод с тем же именем для его базового типа.

### Пример создания значения интерфейсного типа:

Создадим интерфейс Animal, который требует реализации метода Speak().

``` go
type Animal interface {
    Speak() string
}
```

Затем мы создаем переменную animal интерфейсного типа Animal:

``` go
var animal Animal
```

Через конструкцию `fmt.Printf("Value %v, type %T\n", animal, animal)` выведем на экран значение и тип интерфейса `animal`. Увидим следующие сообщение:

``` bash
Value <nil>, type <nil>
```

Здесь мы видим, что `value` и `type` равны nil. Это означает, что переменная animal не содержит никакого значения и не указывает на конкретный тип. 

При попытке сравнить интерфейс с nil мы видим, что сообщение "animal is not nil" не распечатается.

``` go
if animal != nil {
    fmt.Println("animal is not nil")
}
```

Создадим указатель на новый объект Dog и присвоим dog интерфейсу animal.

``` go
dog := &Dog{}
animal = dog
```

Теперь, когда animal указывает на объект Dog, мы можем вызвать метод Speak. Это безопасно, потому что Dog реализует метод Speak, требуемый интерфейсом Animal.

``` go
animal.Speak() // OK
```

Снова воспользуемся конструкцией `fmt.Printf("Value %v, type %T\n", animal, animal)` выведем на экран значение и тип интерфейса. Увидим следующие сообщение:

``` bash
Value &{}, type *main.Dog
```

Тип: %T показывает, что animal — это указатель на Dog (*main.Dog).

Затем мы проверяем, не равна ли animal nil:

``` go
if animal != nil {
    fmt.Println("animal is not nil")
}
```

Поскольку animal указывает на объект Dog, условие выполняется, и выводится сообщение "animal is not nil".

Изменим поле Name у объекта Dog, на который указывает dog

``` go
dog.Name = "Шайтан"
```

Выводем снова через `Printf` тип и значение переменной animal:

``` go
Value &{Шайтан}, type *main.Dog
```

Теперь значение интерфейса поля Name обновлено до "Шайтан", что видно в выводе.

### Вызов метода интерфейсного типа
Значение интерфейсного типа != nil, когда
конкретный тип != nil. Мы можем безопасно вызвать метод у интерфейса только в случае, когда значение интерфейсного типа != nil. В противном случае при вызове метода мы словим панику.

``` go
var animal Animal
animal.Speak() // паника при попытке вызвать (interface == nil)

dog := &Dog{}
animal = dog // interface != nil
animal.Speak() // OK
```

### Второй пример создания значения интерфейсного типа:

Создадим свой пользовательский тип Binary с двумя методами `String() string` и `Get() uint64`.

```go
type Binary uint64

func (i Binary) String() string {
    return strconv.Uitob64(i.Get(), 2)
}

func (i Binary) Get() uint64 {
    return uint64(i)
}
```

Создадим экземпляр нашей структуры и присвоим ему значение:

![gointer1](images/gointer1.png)

Значение интерфейса представлены в виде пары из двух машинных слов, дающей указатель на информацию о типе, хранящемся в интерфейсе, и указатель на связанные данные.

![gointer2](images/gointer2.png)
(Указатели, содержащиеся в значении интерфейса, выделены серым цветом, чтобы подчеркнуть, что они неявные и не доступны напрямую программам Go.)

Первое слово в значении интерфейса указывает на таблицу интерфейсов `itable`. В нем хранится информация о конкретном типе `type` и списке указателей на методы `fun[0]`. В нашем случае `type`- `Binary`, методы `String() string` и `Get() uint64`.

Второе слово указывает на значение `data`. В нашем случае `data` - 200.

Через конструкцию `fmt.Printf("Value %v, type %T\n", num, num)` выведем на экран значение и тип интерфейса. Получим:

``` bash
Value 11001000, type main.Binary
```

### Неявная имплементация

В Go используется неявная имплементация. В других языках требуется использование ключевого слово `implements`. У нас используется утиная типизация. Для того, чтобы имплементировать интерфейс необходимо реализовать все его методы. При этом можно реализовать больше методов чем это требуется, но меньше нельзя. Один тип может имплементировать несколько интерфейсов.

### Вопрос на собеседовании
Обладая этими знаниями, вы сможете ответить на популярный [вопрос из собеседования](https://github.com/alivewel/sber-tasks/tree/main/10_interface):

#### Что выведет программа?

```go
func main() {
	var ptr *struct{}
	var iface interface{}
	iface = ptr
	if iface == nil {
		println("It's nil!")
	}
} 
```

### Пустой интерфейс

Пустой интерфейс - это интерфейс, у которого отсутствуют методы. Для имплементации интерфейса нужно реализовать всего его методы. Для имплементации пустого интерфейса не нужно реализовывать никаких методов. Соответственно, любой тип в go имплементирует пустой интерфейс. В других языках программирования такое называется `any`. В go тоже есть `any`, это алиас (пользовательский тип) на пустой интерфейс.

При создании переменной пустого интерфейса в дальнейшем мы можем присвоить ему любой тип. 

```go
var emptyInterface interface{}

emptyInterface = dog

emptyInterface = 123

emptyInterface = true
```

### Цитата про пустой интерфейс из статьи про постулаты Go ([Go proverbs](https://habr.com/ru/articles/272383/))

#### Пустой интерфейс ни о чём не говорит (interface{} says nothing)

Этот постулат говорит о том, что интерфейсы — «поведенческие типы» — должны что-то означать. Если вы создаёте интерфейс, это что-то означает и служит конкретной цели. Пустой же интерфейс (`interface{}`) ничего не означает и ни о чём не говорит. 

Есть ситуации, когда его нужно использовать, но они чаще исключение — **не используйте `interface{}` без повода**. Новички часто переиспользуют пустые интерфейсы, и масса вопросов на Stack Overflow именно о них.

### Полиморфизм

Полиморфизм — это концепция, позволяющая объектам разных типов быть обработанными через единый интерфейс. В данном примере полиморфизм проявляется в том, что функция MakeAnimalSpeak может принимать любой тип, который реализует интерфейс Animal, и вызывать метод Speak, не зная конкретного типа объекта.
Это позволяет писать более гибкий и расширяемый код, так как вы можете добавлять новые типы, реализующие интерфейс Animal, без необходимости изменять существующий код, который работает с этим интерфейсом.
С помощью интерфейсов мы можем обстрагироваться от конкретных типов.

### Пример

Обе структуры Dog и Cat реализуют метод Speak, что делает их совместимыми с интерфейсом Animal. Метод Speak возвращает строку, описывающую звук, который издает животное.

Функция MakeAnimalSpeak принимает параметр типа Animal. Поскольку Dog и Cat реализуют интерфейс Animal, они могут быть переданы в эту функцию. Внутри функции вызывается метод Speak, который возвращает строку, и эта строка выводится на экран.
Aункция MakeAnimalSpeak принимает параметр типа Animal. Поскольку Dog и Cat реализуют интерфейс Animal, они могут быть переданы в эту функцию. Внутри функции вызывается метод Speak, который возвращает строку, и эта строка выводится на экран.

```go
type Animal interface {
	Speak() string
}

type Dog struct {
	Name string
}

func (d Dog) Speak() string {
	return fmt.Sprintf("Собака %s лает", d.Name)
}

type Cat struct {
	Name string
}

func (c Cat) Speak() string {
	return fmt.Sprintf("Кошка %s мяукает", c.Name)
}

// Функция, принимающая интерфейс Animal и вызывающая метод Speak
func MakeAnimalSpeak(a Animal) {
	fmt.Println(a.Speak())
}

func main() {
	dog := Dog{Name: "Шайтан"}
	cat := Cat{Name: "Тайсон"}

	// Вызов функции MakeAnimalSpeak для каждого животного
	MakeAnimalSpeak(dog)
	MakeAnimalSpeak(cat)
}
```

### Type Assertion
Type Assertion позволяет нам вызывать только те методы, которые существуют у данного конкретного типа. Она возвращает две переменные: значение конкретного типа и флаг, указывающий на успешность преобразования значения интерфейсного типа в конкретный тип. После успешного преобразования мы можем вызывать методы, специфичные для этого конкретного типа.

Для каждой структуры `Dog` и `Cat` мы добавили уникальные методы:
```go
func (d Dog) Bark() string {
	return fmt.Sprintf("%s громко лает!", d.Name)
}

func (c Cat) Purr() string {
	return fmt.Sprintf("%s мурлычет.", c.Name)
}
```

Создадим функцию `processAnimalTypeAssertion`, которая принимает на вход интерфейс `Animal` и выполняет `type assertion` для проверки конкретного типа, чтобы вызвать его уникальные методы:

```go
func processAnimalTypeAssertion(animal Animal) {
	if dog, ok := animal.(*Dog); ok {
		fmt.Printf("Type: %T Value: %#v\n", dog, dog)
		fmt.Println(dog.Bark())
	}
	if cat, ok := animal.(*Cat); ok {
		fmt.Printf("Type: %T Value: %#v\n", cat, cat)
		fmt.Println(cat.Purr())
	}
}
```

Вызовем функцию `processAnimalTypeAssertion` в `main`.

```go
func main() {
	dog := &Dog{Name: "Шайтан"}
	cat := &Cat{Name: "Тайсон"}

	processAnimalTypeAssertion(dog)
	processAnimalTypeAssertion(cat)
}
```

При выполнении этого кода получим следующий вывод:

```go
Type: *main.Dog Value: &main.Dog{Name:"Шайтан"}
Шайтан громко лает!
Type: *main.Cat Value: &main.Cat{Name:"Тайсон"}
Тайсон мурлычет.
```

### Type Switch

Type Switch предоставляет синтаксический сахар для работы с Type Assertion. Таким образом можем заменить функцию processAnimalTypeAssertion функцией processAnimalTypeSwitch:

```go
func processAnimalTypeSwitch(animal Animal) {
	switch v := animal.(type) {
	case *Dog:
		fmt.Printf("Type: %T Value: %#v\n", v, v)
		fmt.Println(v.Bark())
	case *Cat:
		fmt.Printf("Type: %T Value: %#v\n", v, v)
		fmt.Println(v.Purr())
	default:
		fmt.Printf("Type: %T Value: %#v\n", v, v)
	}
}
```
