Корневое дерево - это дерево, в котором по условиям задачи дан корень.

Очень важно на собеседовании перед тем как писать код рассказать интервьюреру сколько будет занимать времени и памяти выбранный алгоритм.

В данном случае, если у нас количество вершин - n, то time: O(n), mem O(h), где h - высота дерева. Высота дерева - это расстояние от корня до листа.

Тут зависит от реализации, но в любом случае для обхода дерева нам понадобиться стек. Мы можем сами его создать или с помощью рекурсии, но в любом случае он нам нужен.

Также нам нужно знать высоту дерева - h, какая максимальная высота дерева. Здесь мы вводим такое понятие, как бамбук. Бамбук - это дерево, которое не имеет ветвей, он растет строго вверх. В нашем случае дерево может быть несбалансировано и оно может превратиться в односвязный список. В худшем случае высота дерева станет равным количеству элементу в дереве - O(n).

Рекурсивный подход. Стоит ли?
Есть мнение - Можно без рекурсии. Рекурсия не есть хорошо.
На собесе можно спросить - сколько вершин? Обычно говорят что около 1000 или отвечают немного. Потом можно спросить - Я хочу написать рекурсивное решение. Нормально ли это для вас? Обычно отвечают да.
Иногда бывают кейсы, в яндексе могут сказать, у нас бесконечное дерево. Тогда можно спросить. Я могу написать рекурсивно и нет. Как лучше это сделать. Они говорят лучше рекурсивно. 
Рекурсивный подход всем привычный и деревья обычно все сбалансированы. Рекурсивного решения всегда достаточно.
Единственный кейс, когда нужно нерекурсивно, это обычно в требованиях к задаче могут написать, что нужно нерекурсивно пройтись по дереву. Это только на литкоде может быть.

Отличие PreOrder и InOrder обхода.
PreOrder - действие, влево, вправо.
InOrder  - влево, действие, вправо.

PostOrder
PostOrder - влево, вправо, действие.