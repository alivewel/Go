### Worker Pool

Довольно часто в архитектуре встречается случаи, когда работа осуществляется через какие-то очереди. С которыми работают оффлайновые разгребаторы. Часто для этих целей есть воркающиеся демоны, но в го можно поступить гораздо проще. Мы можем создать несколько горутин, которые будут читать из какого-то канала и если к нам приходит какая-то задача мы будем писать ее в этот канал.

У нас есть 3 воркера, которые выводят что-то на экран. Внутри функции мы читаем из канала и выводим прочитанное значение на экран. При этом если нам больше не нужен пул воркеров, мы можем просто закрыть этот канал. И когда цикл который крутиться внутри воркеров прервет свою работу. При этом если не закрыть этот канал и запустить программу, мы увидим, что сообщение 'Worker # finished' не выведется на экран. 
Почему так происходит? Мы не дождались выполнения работы воркера. Горутина main завершила свою работу и стала ждать выполнения других горутин. Поэтому воркер завершился некорректно. В других случаях это может привести к утечкам горутин и деадлоку. Будьте осторожны.

Мое примечание: 

1) runtime.Gosched()
В версии Go до 1.14 планировщик был кооперативный, это значит что он не трогал горутины до тех пор пока она не выполнит свою работу. Для того, чтобы передавать управление другим горутинам нужно было принудительно вызывать функцию runtime.Gosched(). 
В версии Go 1.14 планировщику добавили вытесняющую многозадачность. Теперь он тоже может снимать горутины с выполнения один раз в 10мс.
Подробнее можно прочитать здесь: https://habr.com/ru/articles/502506/


Отличный вопрос! Закрытие канала в этом коде действительно работает как примитив синхронизации.
Почему printFinishWork не отрабатывается, если канал не закрывается?
Когда канал не закрывается, горутины, которые читают из этого канала, будут ждать, пока в канал не будут отправлены новые данные. Однако, в данном случае, после того, как все месяцы были отправлены в канал, больше ничего не отправляется. Поэтому горутины, вызывающие startWorker, будут ждать вечно, не достигая строки printFinishWork.
Как закрытие канала решает эту проблему?
Когда канал закрывается, это сигнализирует горутинам, что больше данных не будет поступать. Таким образом, цикл for input := range in в startWorker завершается, и функция может вызвать printFinishWork, сообщая о завершении работы.
Другими словами, закрытие канала служит сигналом для горутин, что они могут завершить свою работу. Без этого сигнала, горутины будут ждать вечно, не достигая конца своего выполнения.
Заключение
Закрытие канала в этом коде действительно работает как примитив синхронизации. Оно сообщает горутинам, что больше данных не будет поступать, позволяя им завершить свою работу и вызвать printFinishWork. Это важный момент в использовании каналов для координации параллельных операций в Go.
