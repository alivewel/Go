### **Подробный алгоритм с использованием стека (без кода)**

Чтобы получить правильный результат (`"acdb"` для `"cbacdcbc"`), нужно соблюсти три условия:
1. **Удалить все дубликаты** (каждая буква — 1 раз).
2. **Сохранить относительный порядок** первых вхождений букв.
3. **Сделать строку минимальной** в лексикографическом порядке.

Для этого используется **стек** (структура данных "последним пришёл — первым ушёл") и **учёт оставшихся букв**. Вот как это работает:

---

### **Шаг 1: Подготовка данных**
1. **Посчитаем частоту букв** в строке (сколько раз каждая буква встречается).  
   Для `"cbacdcbc"`:  
   - `'a'`: 1, `'b'`: 2, `'c'`: 4, `'d'`: 1.

2. **Создадим стек** для хранения результата и **множество** для отслеживания уже использованных букв.

---

### **Шаг 2: Обработка символов по порядку**
Для каждого символа `s[i]` в строке:
1. **Уменьшаем его частоту** (т.к. мы его "использовали").
2. Если символ **уже в стеке** — пропускаем (чтобы избежать дублей).
3. **Пока стек не пуст** и:
   - Текущий символ `s[i]` **меньше** последнего символа в стеке (`stack[-1]`),  
   - И последний символ стека **ещё встретится** в оставшейся строке (частота > 0),  
   - **Удаляем символ из стека** (чтобы сделать результат лексикографически меньшим).
4. **Добавляем текущий символ** в стек.

---

### **Шаг 3: Пример для `"cbacdcbc"`**
Разберём посимвольно:

| Символ | Стек (до обработки) | Действие                                                                 | Стек (после) |
|--------|---------------------|--------------------------------------------------------------------------|--------------|
| `'c'`  | `[]`                | Добавляем `'c'` (стек пуст)                                              | `['c']`      |
| `'b'`  | `['c']`             | `'b'` < `'c'`, но `'c'` ещё встретится (частота `'c'`=3) → удаляем `'c'` | `['b']`      |
| `'a'`  | `['b']`             | `'a'` < `'b'`, `'b'` встретится ещё (частота `'b'`=1) → удаляем `'b'`    | `['a']`      |
| `'c'`  | `['a']`             | `'c'` > `'a'` → просто добавляем `'c'`                                   | `['a', 'c']` |
| `'d'`  | `['a', 'c']`        | `'d'` < `'c'`, но `'c'` встретится (частота `'c'`=2) → удаляем `'c'`     | `['a', 'd']` |
| `'c'`  | `['a', 'd']`        | `'c'` > `'d'` → добавляем `'c'`                                          | `['a', 'd', 'c']` |
| `'b'`  | `['a', 'd', 'c']`   | `'b'` < `'c'`, но `'c'` больше не встретится (частота `'c'`=0) → оставляем стек. Добавляем `'b'`. | `['a', 'd', 'c', 'b']` |
| `'c'`  | `['a', 'd', 'c', 'b']` | Уже в стеке → пропускаем.                                                | `['a', 'd', 'c', 'b']` |

**Итоговый стек**: `['a', 'c', 'd', 'b']` → `"acdb"`.

---

### **Ключевые моменты:**
1. **Удаление из стека**:  
   Символ удаляется из стека, только если:
   - Текущий символ **меньше** последнего в стеке.  
   - Последний символ стека **ещё встретится** позже (частота > 0).  

2. **Лексикографический минимум**:  
   Алгоритм жертвует порядком некоторых символов (например, `'c'` и `'b'`), чтобы поставить меньшие буквы (`'a'`, `'d'`) как можно раньше.

3. **Сложность**:  
   - Время: **O(n)** (каждый символ обрабатывается один раз).  
   - Память: **O(n)** (для стека и множества).

---

### **Почему это работает?**
Алгоритм гарантирует, что:
- Каждая буква встречается **ровно один раз**.  
- Результат **лексикографически минимален**, потому что мы "выталкиваем" из стека большие символы, если есть шанс поставить меньшие раньше.  
- **Относительный порядок** сохраняется для критичных символов (которые больше не повторятся).

Для `"cbacdcbc"` нельзя получить `"abcd"`, потому что `'a'` изначально стоит после `'c'` и `'b'`, и их нельзя "перепрыгнуть" без нарушения условий.