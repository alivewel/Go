1) Забыл сдвинуть указатели в else случае

``` go
func threeSum(nums []int) [][]int {
    // отсортировать массив
	sort.Ints(nums)
	res := make([][]int, 0)
	for i := 0; i < len(nums)-1; i++ {
		l, r := i + 1, len(nums)-1
        if i < 0 && num[i] == num[i-1] {
            continue
        }
		for l < r {
			if nums[i] + nums[l] + nums[r] > 0 {
                for nums[r] == nums[r-1] {
                    r--
                }
			} else if nums[i] + nums[l] + nums[r] < 0 {
                for nums[l] == nums[l+1] {
                    l++
                }
			} else {
				res = append(res, []int{nums[i], nums[l], nums[r]})
				// забыл сдвинуть указатели
				r--
				l++
			}
		}
	}
	return res
}
```

2) Забыл добавить обработку дублей. Для nums[i] добавил.
Для nums[l] и nums[r] не смог додуматься как это сделать.
 
``` c
func threeSum(nums []int) [][]int {
    // отсортировать массив
	sort.Ints(nums)
	res := make([][]int, 0)
	for i := 0; i < len(nums)-1; i++ {
		l, r := i + 1, len(nums)-1
		if i > 0 && nums[i] == nums[i-1] {
            continue
        }
		for l < r {
			if nums[i] + nums[l] + nums[r] > 0 {
				r--
                // for r < len(nums) && nums[r] == nums[r-1] {
                //     r--
                // }
			} else if nums[i] + nums[l] + nums[r] < 0 {
				l++
                // for l+1 < len(nums) && nums[l] == nums[l+1] {
                //     l++
                // }
			} else {
				res = append(res, []int{nums[i], nums[l], nums[r]})
				// забыл сдвинуть указатели
				r--
				l++
			}
		}
		// добавить обработку дублей
	}
	return res
}
```

3) Обрабатывал дубли не в том месте. Нужно в else случае, когда мы нашли равенство.

```go
func threeSum(nums []int) [][]int {
    // отсортировать массив
	sort.Ints(nums)
	res := make([][]int, 0)
	for i := 0; i < len(nums)-1; i++ {
		l, r := i + 1, len(nums)-1
		if i > 0 && nums[i] == nums[i-1] {
            continue
        }
		for l < r {
			if nums[i] + nums[l] + nums[r] > 0 {
				r--
			} else if nums[i] + nums[l] + nums[r] < 0 {
				l++
			} else {
				res = append(res, []int{nums[i], nums[l], nums[r]})
				// забыл сдвинуть указатели
				r--
				l++
				for l < r && nums[r] == nums[r-1] {
                    r--
                }
				for l < r  && nums[l] == nums[l+1] {
                    l++
                }
			}
		}
		// добавить обработку дублей
	}
	return res
}
```

4) Обработки дублей не работает корректно из-за **неправильного порядка проверки и сдвига указателей**. 
---

### **1. Проблема в моем коде**
Ваш код для обработки дублей выглядит так:
```go
r--
l++
for l < r && nums[r] == nums[r-1] {
    r--
}
for l < r && nums[l] == nums[l+1] {
    l++
}
```

#### Ошибки:
1. **Сдвиг указателей `r--` и `l++` происходит до проверки дублей**:
   - Вы сначала уменьшаете `r` и увеличиваете `l`, а затем проверяете, есть ли дубли. Это может привести к пропуску корректных значений или к некорректной обработке.
   - Например, если `nums[l]` или `nums[r]` уже указывали на дублирующее значение, вы пропустите их без проверки.

2. **Логика проверки дублей для `nums[r]` и `nums[l]` нарушена**:
   - Вы проверяете `nums[r] == nums[r-1]` и `nums[l] == nums[l+1]`, но это не всегда корректно, так как указатели уже сдвинуты. Это может привести к тому, что вы пропустите нужные значения.

---

### **2. Как исправить**
Чтобы правильно обработать дубли, нужно:
1. **Сначала обработать текущие значения `nums[l]` и `nums[r]`, а затем сдвигать указатели**.
2. **Проверять дубли после сдвига указателей, а не до**.

Исправленный код:
```go
res = append(res, []int{nums[i], nums[l], nums[r]})
l++
r--
// Пропускаем дубли для l
for l < r && nums[l] == nums[l-1] {
    l++
}
// Пропускаем дубли для r
for l < r && nums[r] == nums[r+1] {
    r--
}
```

---

### **3. Почему это работает**
- После нахождения тройки, вы сначала сдвигаете указатели `l++` и `r--`, чтобы перейти к следующему возможному значению.
- Затем вы проверяете, не указывают ли новые значения `nums[l]` и `nums[r]` на дублирующиеся элементы:
  - Если `nums[l] == nums[l-1]`, это значит, что `nums[l]` повторяется, и нужно продолжить сдвигать `l`.
  - Если `nums[r] == nums[r+1]`, это значит, что `nums[r]` повторяется, и нужно продолжить сдвигать `r`.

---

### **4. Итог**
Ваш способ не работает из-за неправильного порядка действий. После исправления порядок будет таким:
1. Найти тройку.
2. Сдвинуть указатели `l++` и `r--`.
3. Пропустить дубли, проверяя новые значения `nums[l]` и `nums[r]`.

