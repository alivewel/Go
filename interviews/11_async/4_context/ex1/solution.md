### Контекст

Основная цель контекста отмена асинхронных операций.

Допустим мы отправляем запросы на несколько разных серверов. При этом на нужен только первый из них, все остальные запросы мы не ждем. Можно реализовать ожидание используя канал, но обычно для этого используют контекст.

Мы будет использовать context.WithCancel, который возвращает нам контекст ctx и функцию отмены finish, которую мы можем вызвать в в дальнейшем.

context.Background() - это базовый контекст от которого все в дальнейшем наследуются.

В цикле мы запускаем 10 воркеров, первым параметров в который мы передаем контекст (контекст всегда передается первым параметром в функции), номер воркера и канал с результатом. После этого мы дожидаемся первый результат, выводим его на экран и вызываем функцию finish.

Каким образом обратывается этот сигнал? Сигнал обрабатывается посредство чтения канала, который возвращает нам метод контекста Done(). Это безопасно использовать между несколькими горутинами. Мы эмулируем работу через Sleep. Как только пришло время работы этого воркера мы запишем этот результат в канал и выведем на экран сообщение "worker # done". Если нам придет сигнал, что нам нужно закругляться (<-ctx.Done()), мы просто выйдем из функции - return.

При запуске программы мы видим, что горутина у которой было сгенерировано минимальная задержка отправила сообщение в канал result, мы его получили в канале foundBy, вызвали метод finish() и всем другим горутинам послали сигнал завершить работу (у них отработался case <-ctx.Done()).

-1:33:00