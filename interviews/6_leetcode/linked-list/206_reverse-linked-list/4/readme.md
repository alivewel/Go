Разбор решения:

```go
func reverseList(head *ListNode) *ListNode {
    var prev *ListNode
    cur := head
    for cur != nil {
        nextNode := cur.Next
        cur.Next = prev // 
        prev = cur
        cur = nextNode
    }
    return prev
}
```

--------

Конечно! Давай разберём твой код построчно и восстановим логику, как работает итеративный разворот односвязного списка:

```go
func reverseList(head *ListNode) *ListNode {
```

Это сигнатура функции. Она принимает указатель на голову связного списка `head` и возвращает новую голову (после разворота списка).

---

```go
    var prev *ListNode
```

Инициализация переменной `prev`, которая будет указывать на предыдущий узел в процессе разворота. В начале — `nil`, потому что хвост нового списка (бывшая голова) будет указывать на `nil`.

---

```go
    cur := head
```

Создаём переменную `cur`, которая будет перемещаться по текущим узлам списка. Изначально она указывает на голову входного списка.

---

```go
    for cur != nil {
```

Цикл продолжается, пока мы не достигли конца списка (`nil`).

---

```go
        nextNode := cur.Next
```

Сохраняем следующий узел, чтобы не потерять доступ к остальной части списка после того, как изменим ссылку `cur.Next`.

---

```go
        cur.Next = prev
```

Меняем направление текущей стрелки (ссылки): `cur.Next` теперь указывает на предыдущий узел (`prev`), а не на следующий. Это и есть ключевой шаг разворота.

---

```go
        prev = cur
```

Сдвигаем `prev` вперёд — теперь он указывает на текущий узел. То есть он становится предыдущим для следующей итерации.

---

```go
        cur = nextNode
```

Сдвигаем `cur` вперёд по исходному списку — на следующий узел.

---

```go
    }
    return prev
}
```

Когда цикл завершится (дошли до конца списка), `cur` станет `nil`, а `prev` будет указывать на последний обработанный узел — то есть на новую голову развернутого списка. Мы его и возвращаем.

---

### Пример

Допустим, входной список:

```
1 -> 2 -> 3 -> nil
```

Пошагово будет:

```
prev = nil
cur = 1

--- итерация 1 ---
nextNode = 2
cur.Next = nil      // 1 -> nil
prev = 1
cur = 2

--- итерация 2 ---
nextNode = 3
cur.Next = 1        // 2 -> 1 -> nil
prev = 2
cur = 3

--- итерация 3 ---
nextNode = nil
cur.Next = 2        // 3 -> 2 -> 1 -> nil
prev = 3
cur = nil
```

Готово! `prev` указывает на `3`, то есть на новую голову развернутого списка.

Хочешь, я распишу аналогичный рекурсивный вариант или сделаем визуализацию?
