В этом примере рассмотрим прикладное применение каналов и горутин. Начнем с ускорения работы некоторых запросов путем их распарллеливания.

В данном примере у нас есть страница со статьей с какими-то комментариями и какие-то связанные статьи. При этом комментарии и статьи никак не связаны, хотя чаще всего на странице они распологаются последовательно. В го можно распараллелить эту работу внеся тяжелую операцию в отдельную горутину, которая будет общаться с программой через канал.

В функции getPage мы вызываем функцию getComments, которая возвращаем канал. После этого делаем небольшую паузу (имитация получения связных статей). И только после этого дожидаемся получения комментариев.
Итого в главной горутины мы получили связные статьи и параллельно с этим мы получили комментарии. В функции getComments мы создаем дополнительную горутину, в которой будет выполняться вся полезная работа. В данном случае это time.Sleep, но мы можем вместо этого выполнить SQL-запрос. Когда операция закончится в канал запишется результат. В данном примере есть небольшой нюанс. В случае использования небуфферизированого канала (result := make(chan string)) и в случае невозможности чтения (commentsData := <-resultCh) по какой-то причине (ошибка с БД) мы выйдем из функции и не прочитаем значение из канала. В этом случае получится, что горутина пытается записать в канал синхронно, ожидая с другой стороны чтение, но оттуда уже никто не читает, мы получим утечку горутин и как следствие утечку памяти. Поэтому канал должен быть буферизированным и иметь буфер 1. Это дает нам записать хотя бы одно значение в канал не блокируясь. Если вдруг мы не дошли до функции чтения из канала, то мы запишем туда результат, функция корректно выполниться и завершиться, а сам канал уберется сборщиком мусора. Потому что из него никто не пытается читать и писать. Это очень интересный инструмент в работе и позволяет неплохо оптимизировать некоторые операции.