### Max Consecutive Ones II - Описание задачи

Дан бинарный массив `nums`, состоящий только из `0` и `1`. Ваша задача — найти **максимальное количество подряд идущих единиц** в массиве, если разрешено **заменить не более одного `0` на `1`**.

---

### Ограничения:
- Массив состоит только из чисел `0` и `1`.
- Длина массива — положительное число, не превышающее 10,000.

---

### Примеры:

1. **Пример 1**:
   - **Ввод**: `nums = [1,0,1,1,1,0,0,1,1]`
   - **Вывод**: `5`
   - **Объяснение**: Если заменить первый `0` на `1`, массив станет `[1,1,1,1,1,0,0,1,1]`, где есть 5 подряд идущих единиц.

2. **Пример 2**:
   - **Ввод**: `nums = [1,0,1,1,0,1]`
   - **Вывод**: `4`
   - **Объяснение**: Если заменить первый `0` на `1`, массив станет `[1,1,1,1,0,1]`, где есть 4 подряд идущих единицы.

3. **Пример 3**:
   - **Ввод**: `nums = [1,1,0,1]`
   - **Вывод**: `4`
   - **Объяснение**: Если заменить `0` на `1`, массив станет `[1,1,1,1]`, где есть 4 подряд идущих единицы.

4. **Пример 4**:
   - **Ввод**: `nums = [0,0,0,0]`
   - **Вывод**: `1`
   - **Объяснение**: Если заменить любой `0` на `1`, в массиве будет только одна единица.

---

### Дополнительный вопрос:
Что если числа поступают в виде **бесконечного потока данных** (infinite stream)? То есть, вы не можете хранить весь массив в памяти. Как можно эффективно решить эту задачу в таком случае?







### Условие задачи

Дан массив `nums`, состоящий только из нулей и единиц. Нужно вернуть **максимальное число подряд идущих единиц** при условии, что можно заменить **один ноль** на единицу.

---

### Пример

- **Ввод**: `nums = [1,0,1,1,1,0,0,1,1]`
- **Вывод**: `5`
- **Объяснение**: Нужно заменить первый ноль на единицу.

---

### В чем сложность задачи?

Давайте выделим все потенциальные подмассивы, которые могут нас интересовать. Мы получим следующие подмассивы, содержащие не более одного нуля:  
`[1,0,1,1,1]`, `[1,1,1,0]`, `[0]`, `[0,1,1]`.  

Можно заметить, что **эти подмассивы пересекаются**, и поэтому не получится использовать ранее изученный паттерн **"непересекающиеся окна"**.

---

### Общий алгоритм решения

Мы будем действовать по следующему алгоритму: заведём два указателя `l` и `r`, где `l` указывает на начало плавающего окна, а `r` — на его конец (включительно).

1. **Расширение окна**:  
   Будем двигать правый указатель `r` вправо, пока `r + 1` меньше длины массива и (элемент `nums[r+1]` равен `1` или количество нулей в окне `zerosCount` меньше `1`).  
   То есть, пока можем добавить следующий элемент в окно.

2. **Обработка нуля**:  
   Если при сдвиге правого указателя встречаем ноль и он единственный в окне, то запоминаем его индекс в `zeroIdx` и увеличиваем `zerosCount`.

3. **Обновление результата**:  
   Если не можем двигать правый указатель, значит достигнут максимальный размер окна при текущем `l`.  
   Обновляем ответ:  
   `result = max(result, windowSize)`, где `windowSize = r - l + 1`.

4. **Сдвиг левого указателя**:  
   Сдвигаем левый указатель `l` на `1` вправо и, если элемент `nums[l]` был нулём, уменьшаем `zerosCount`.  
   Это позволяет нам передвинуть окно и продолжить поиск.

5. **Повторение**:  
   Повторяем шаги 1–4, пока левый указатель `l` не достигнет конца массива.
