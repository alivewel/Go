Вопрос:
### почему мы не передаем канал внутрь горутины и почему это работает? что будет если передать его?

```go
func mergeSorted(a, b <-chan int) <-chan int {
	out := make(chan int) // Создаем выходной канал
	go func() {
    ...
	}()
	return out // Возвращаем выходной канал
}
```

Ответ:

В функции mergeSorted, когда мы создаем горутину, мы не передаем канал out внутрь горутины, потому что он доступен в замыкании. В Go, когда вы создаете анонимную функцию (горутину), она захватывает переменные из окружающего контекста, включая каналы. Это означает, что вы можете использовать out внутри горутины без явной передачи.

Почему это работает
Замыкание: Горутина имеет доступ к переменным, объявленным в функции, где она была создана. Это называется замыканием. Поэтому, когда вы создаете горутину, она может использовать out, даже если он не передан как аргумент.
Безопасность: Использование замыкания позволяет избежать дополнительных параметров, что делает код более чистым и понятным. Это также уменьшает вероятность ошибок, связанных с передачей неправильных значений.

```go
func mergeSorted(a, b <-chan int) <-chan int {
	out := make(chan int) // Создаем выходной канал
	go func() {
	}()
	return out // Возвращаем выходной канал
}
```

Что будет, если передать канал внутрь горутины?
Если вы решите передать канал out как аргумент в горутину, это также будет работать, но это не обязательно. Например, вы можете изменить код следующим образом:

```go
go func(out chan int) {
    defer close(out)
    // Логика слияния
}(out)
```

Разница между подходами
Передача канала: Это может быть полезно, если вы хотите сделать код более явным или если вы планируете передавать несколько каналов или другие параметры в горутину. Однако это добавляет лишние параметры, которые могут усложнить чтение кода.
Использование замыкания: Это более идиоматичный способ в Go, который делает код более лаконичным и понятным. Вы можете легко видеть, какие переменные используются внутри горутины, не беспокоясь о том, как они передаются.
