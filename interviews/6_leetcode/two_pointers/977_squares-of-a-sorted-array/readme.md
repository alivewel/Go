### **Описание задачи: Squares of a Sorted Array**

Дана целочисленная сортированная в неубывающем порядке последовательность `nums`. Необходимо вернуть новый массив, содержащий квадраты всех чисел из `nums`, также отсортированный в неубывающем порядке.

---

### **Условия задачи**
1. Массив `nums` уже отсортирован в неубывающем порядке.
2. Массив может содержать как отрицательные, так и положительные числа.
3. Результирующий массив должен быть отсортирован в неубывающем порядке.

---

### **Примеры**

#### Пример 1:
```
Ввод: nums = [-4, -1, 0, 3, 10]
Вывод: [0, 1, 9, 16, 100]
Объяснение:
Квадраты чисел: [16, 1, 0, 9, 100].
После сортировки: [0, 1, 9, 16, 100].
```

#### Пример 2:
```
Ввод: nums = [-7, -3, 2, 3, 11]
Вывод: [4, 9, 9, 49, 121]
Объяснение:
Квадраты чисел: [49, 9, 4, 9, 121].
После сортировки: [4, 9, 9, 49, 121].
```

---

### **Подсказки**
1. **Особенность отрицательных чисел**:
   - Квадраты отрицательных чисел становятся положительными, но их порядок меняется (например, `-4` становится `16`, а `-1` становится `1`).
   - Поэтому важно учитывать, что квадраты отрицательных чисел могут быть больше квадратов положительных чисел.

2. **Оптимизация**:
   - Хотя можно сначала возвести все числа в квадрат, а затем отсортировать массив (временная сложность `O(n log n)`), задача подразумевает, что можно сделать это за линейное время `O(n)`.

3. **Два указателя**:
   - Поскольку массив уже отсортирован, можно использовать два указателя: один в начале массива (для наименьших чисел) и другой в конце массива (для наибольших чисел). Это позволяет эффективно находить наибольшие квадраты и заполнять результирующий массив с конца.


----

### **Описание решения задачи**

Самым очевидным решением, которое приходит в голову, является возведение всех чисел массива в квадрат, а затем сортировка результирующего массива. Однако этот подход неэффективен, так как сортировка занимает время `O(n log n)`. Мы можем решить задачу за линейное время `O(n)` с использованием двух указателей.

---

### **Идея решения**
1. Поскольку массив `nums` уже отсортирован в неубывающем порядке, отрицательные числа находятся в начале, а положительные — в конце.
2. Квадраты отрицательных чисел становятся положительными, и их значения могут быть больше квадратов положительных чисел. Поэтому, чтобы получить отсортированный массив квадратов, мы будем сравнивать **модули чисел** с двух концов массива.
3. Для этого используем два указателя:
   - **Левый указатель (`l`)** — указывает на начало массива.
   - **Правый указатель (`r`)** — указывает на конец массива.
4. Мы будем двигать указатели навстречу друг другу, сравнивая модули чисел, и заполнять результирующий массив с конца (так как наибольшие квадраты будут добавляться первыми).

---

### **Пример выполнения алгоритма**

Дан массив `nums = [-3, -2, 0, 1, 3, 5]`. Мы будем использовать два указателя и заполнять результирующий массив `result` с конца.

#### **Шаги выполнения:**

1. **Инициализация**:
   - Указатели: `l = 0` (левый), `r = 5` (правый).
   - Результирующий массив: `result = [_, _, _, _, _, _]` (пустой массив длины `len(nums)`).
   - Индекс для заполнения: `pos = 5` (заполняем с конца).

---

2. **Шаг 1**:
   - Сравниваем модули чисел: `|nums[l]| = |-3| = 3` и `|nums[r]| = |5| = 5`.
   - Так как `|nums[r]| > |nums[l]|`, записываем квадрат числа `nums[r]` в `result[pos]`.
   - Обновляем: `result = [_, _, _, _, _, 25]`.
   - Сдвигаем правый указатель: `r = 4`.
   - Уменьшаем индекс для заполнения: `pos = 4`.

---

3. **Шаг 2**:
   - Сравниваем модули чисел: `|nums[l]| = |-3| = 3` и `|nums[r]| = |3| = 3`.
   - Модули равны, можно взять любое из чисел. Записываем квадрат числа `nums[r]` в `result[pos]`.
   - Обновляем: `result = [_, _, _, _, 9, 25]`.
   - Сдвигаем правый указатель: `r = 3`.
   - Уменьшаем индекс для заполнения: `pos = 3`.

---

4. **Шаг 3**:
   - Сравниваем модули чисел: `|nums[l]| = |-3| = 3` и `|nums[r]| = |3| = 3`.
   - Модули равны, записываем квадрат числа `nums[l]` в `result[pos]`.
   - Обновляем: `result = [_, _, _, 9, 9, 25]`.
   - Сдвигаем левый указатель: `l = 1`.
   - Уменьшаем индекс для заполнения: `pos = 2`.

---

5. **Шаг 4**:
   - Сравниваем модули чисел: `|nums[l]| = |-2| = 2` и `|nums[r]| = |1| = 1`.
   - Так как `|nums[l]| > |nums[r]|`, записываем квадрат числа `nums[l]` в `result[pos]`.
   - Обновляем: `result = [_, _, 4, 9, 9, 25]`.
   - Сдвигаем левый указатель: `l = 2`.
   - Уменьшаем индекс для заполнения: `pos = 1`.

---

6. **Шаг 5**:
   - Сравниваем модули чисел: `|nums[l]| = |0| = 0` и `|nums[r]| = |1| = 1`.
   - Так как `|nums[r]| > |nums[l]|`, записываем квадрат числа `nums[r]` в `result[pos]`.
   - Обновляем: `result = [_, 1, 4, 9, 9, 25]`.
   - Сдвигаем правый указатель: `r = 2`.
   - Уменьшаем индекс для заполнения: `pos = 0`.

---

7. **Шаг 6**:
   - Оба указателя указывают на одно и то же число: `nums[l] = nums[r] = 0`.
   - Записываем квадрат числа `nums[l]` в `result[pos]`.
   - Обновляем: `result = [0, 1, 4, 9, 9, 25]`.

---

### **Результат**
После завершения работы алгоритма, результирующий массив: `result = [0, 1, 4, 9, 9, 25]`.

---

### **Ключевые моменты**
1. **Заполнение с конца**:
   - Мы заполняем массив с конца, начиная с наибольших квадратов, чтобы избежать дополнительной сортировки.
2. **Два указателя**:
   - Левый указатель (`l`) отвечает за отрицательные числа, правый указатель (`r`) — за положительные.
3. **Условие завершения**:
   - Цикл продолжается, пока `l <= r`.

---

### **Сложность**
- **Временная сложность**: `O(n)` — один проход по массиву.
- **Пространственная сложность**:
  - Если не учитывать результирующий массив, то `O(1)` (дополнительной памяти не требуется).
  - Если учитывать результирующий массив, то `O(n)`.

---
