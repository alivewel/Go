Корневое дерево - это дерево, в котором по условиям задачи дан корень.

Очень важно на собеседовании перед тем как писать код рассказать интервьюреру сколько будет занимать времени и памяти выбранный алгоритм.

В данном случае, если у нас количество вершин - n, то time: O(n), mem O(h), где h - высота дерева. Высота дерева - это расстояние от корня до листа.

Тут зависит от реализации, но в любом случае для обхода дерева нам понадобиться стек. Мы можем сами его создать или с помощью рекурсии, но в любом случае он нам нужен.

Также нам нужно знать высоту дерева - h, какая максимальная высота дерева. Здесь мы вводим такое понятие, как бамбук. Бамбук - это дерево, которое не имеет ветвей, он растет строго вверх. В нашем случае дерево может быть несбалансировано и оно может превратиться в односвязный список. В худшем случае высота дерева станет равным количеству элементу в дереве - O(n).

Рекурсивный подход. Стоит ли?
Есть мнение - Можно без рекурсии. Рекурсия не есть хорошо.
На собесе можно спросить - сколько вершин? Обычно говорят что около 1000 или отвечают немного. Потом можно спросить - Я хочу написать рекурсивное решение. Нормально ли это для вас? Обычно отвечают да.
Иногда бывают кейсы, в яндексе могут сказать, у нас бесконечное дерево. Тогда можно спросить. Я могу написать рекурсивно и нет. Как лучше это сделать. Они говорят лучше рекурсивно. 
Рекурсивный подход всем привычный и деревья обычно все сбалансированы. Рекурсивного решения всегда достаточно.
Единственный кейс, когда нужно нерекурсивно, это обычно в требованиях к задаче могут написать, что нужно нерекурсивно пройтись по дереву. Это только на литкоде может быть.

Отличие PreOrder и InOrder обхода.
PreOrder - действие, влево, вправо.
InOrder  - влево, действие, вправо.

PostOrder
PostOrder - влево, вправо, действие.

В самом начале функции Traverse нам нужно проверить node == nil return.

Как мы поняли, что это лист дерева (конец дерева - ветви указывают на nil)?
За это отвечает строка node == nil return. Мы проверяем в самом начале функции.
Есть 2 варианта проверки листа дерева. Это можно сделать прежде чем мы туда пошли и когда мы уже туда пошли. В этом случае мы проверяем, когда уже пошли.

Очень много задач, основанных на PreOrder.

Чтобы переключаться между алгоритмами PreOrder, InOrder и PostOrder. В PreOrder действие происходит в начале, в InOrder по середине, в PostOrder в конце. Для переключения между алгоритмами достаточно сдвинуть строку в котором происходит действие в нужное место.

Отличие PreOrder, InOrder и PostOrder обхода.
PreOrder  - действие, влево, вправо.
InOrder   - влево, действие, вправо.
PostOrder - влево, вправо, действие.


31:30 102 Binary Tree Level Order Traversal
