Table "public.carts"
| Column       | Type                          | Modifiers          |
|--------------|-------------------------------|--------------------|
| sku          | bigint                        | not null           |
| country      | country_enum                  | not null           |
| customer_id  | bigint                        | not null           |
| amount       | bigint                        | not null           |
| updated_at   | timestamp without time zone   | default now()      |

Table "public.customer"
| Column       | Type                          | Modifiers          |
|--------------|-------------------------------|--------------------|
| id           | bigint                        | not null           |
| email        | text                          | not null           |

SKU (Stock Keeping Unit) — уникальный идентификатор товара на складе. Используется для учета и идентификации товаров.

1) 
-- Вывести построчно всех кастомеров (id, email)
-- и все элементы корзины пользователя (sku, amount)

select cust.id, cust.email, carts.sku, carts.amount
from public.customer cust
inner join public.carts carts on cust.id = carts.customer_id
order by 1

INNER JOIN и JOIN в SQL на самом деле являются одним и тем же. Когда вы используете просто JOIN, это подразумевает INNER JOIN по умолчанию. 

При использовании JOIN у нас выведутся только те пользователи у которых есть покупки.
Если мы хотим вывести всех пользователей нужно использовать LEFT JOIN.

Указание полей в SQL-запросе
Если название полей присутствует только в одной таблице, то вы можете не указывать префикс таблицы для этих полей. Однако, даже в этом случае, использование префиксов может улучшить читаемость и понимание запроса, особенно если вы работаете с несколькими таблицами.

Какие типы джойнов еще знаешь?
Left join, right join, FULL JOIN, inner join

### Как работает FULL JOIN?

Основные характеристики FULL JOIN:
Возвращает все строки:
FULL JOIN возвращает все строки из обеих таблиц. Если в одной из таблиц нет соответствующей строки, то в результирующем наборе данных будут заполнены значения NULL для отсутствующих данных.
Сочетание LEFT JOIN и RIGHT JOIN:
FULL JOIN можно рассматривать как объединение результатов LEFT JOIN и RIGHT JOIN. Это означает, что он показывает как совпадающие строки, так и строки, которые не совпадают в обеих таблицах.
NULL значения:
Когда строки из одной таблицы не имеют соответствующих строк в другой таблице, в результирующем наборе данных будут присутствовать NULL значения для столбцов, которые не имеют соответствующих данных.

### Какой тип джойна будет в данном случае?
select *
from public.customer, public.carts

Когда необходимо объединить данные из двух таблиц, включая все строки из обеих таблиц, даже если для некоторых строк нет совпадений, то в этом случае будет использоваться FULL JOIN.

### У нас в таблице public.carts появились записи, у которых нет пользователя. Как вывести такие записи?

select *
from public.carts
where customer_id IS NULL;

а если наоборот, то

SELECT *
FROM public.carts
WHERE customer_id IS NOT NULL;

### Какие индексы ты использовал?

1. GiST (Generalized Search Tree)
Описание: GiST — это обобщенное дерево поиска, которое позволяет создавать индексы для различных типов данных и операций. Он может использоваться для хранения данных, которые не подходят для традиционных B-tree индексов.
Применение: GiST хорошо подходит для работы с геометрическими данными, полнотекстовым поиском и другими сложными типами данных. Например, его можно использовать для индексации данных типа geometry или jsonb.
Преимущества: GiST позволяет выполнять запросы с использованием различных операторов, что делает его гибким инструментом для индексирования. Он также поддерживает диапазонные запросы и может эффективно обрабатывать сложные условия поиска.
2. GIN (Generalized Inverted Index)
Описание: GIN — это обобщенный инвертированный индекс, который особенно полезен для индексации данных, содержащих множество значений, таких как массивы или документы JSON.
Применение: GIN идеально подходит для полнотекстового поиска и индексации массивов. Например, если у вас есть столбец с массивами, GIN индекс позволит быстро находить строки, содержащие определенные элементы массива.
Преимущества: GIN индексы обеспечивают высокую производительность для запросов, которые ищут по множеству значений. Однако они могут занимать больше места на диске и требовать больше времени на обновление по сравнению с B-tree индексами.
3. Hash
Описание: Hash индексы используют хеш-функцию для быстрого поиска строк по значению. Они предназначены для операций равенства.
Применение: Hash индексы могут быть полезны, когда вы часто выполняете запросы с условиями равенства, например, WHERE customer_id = 123.
Преимущества: Hash индексы обеспечивают быструю производительность для операций равенства. Однако они не поддерживают операции сравнения (например, >, <), и в PostgreSQL они менее распространены, чем B-tree индексы.

### И какой индекс стоит использовать для ускорения запросов с customer_id?

CREATE INDEX idx_customer_id ON public.carts (customer_id);

-- по умолчанию PostgreSQL создает B-tree индекс. B-tree индекс: Это наиболее распространенный тип индекса в PostgreSQL, который хорошо подходит для операций поиска, сортировки и диапазонных запросов. Он эффективно обрабатывает запросы на равенство и неравенство, что делает его идеальным для столбцов, таких как customer_id

### Какие минусы от использования индексов?

1. Увеличение затрат на хранение
Индексы занимают дополнительное место на диске. Каждый индекс требует хранения структуры данных, что может привести к значительному увеличению объема базы данных, особенно если индексов много или они создаются на больших таблицах.
2. Замедление операций записи
При добавлении, обновлении или удалении данных в таблице, все соответствующие индексы также должны быть обновлены. Это может привести к увеличению времени выполнения операций записи, так как система должна поддерживать актуальность индексов.
3. Сложность управления
С увеличением количества индексов может возникнуть сложность в управлении ими. Необходимость периодически пересматривать и оптимизировать индексы может потребовать дополнительных ресурсов и времени.
4. Потенциальное ухудшение производительности
В некоторых случаях наличие слишком большого количества индексов может ухудшить производительность запросов. Это связано с тем, что оптимизатор запросов может выбирать менее эффективный индекс для выполнения запроса, что приведет к увеличению времени выполнения.
5. Необходимость анализа и тестирования
Для эффективного использования индексов необходимо проводить анализ и тестирование, чтобы определить, какие индексы действительно нужны. Это требует времени и ресурсов, особенно в больших и сложных базах данных.

2) Вывести топ-10 клиентов (id, email) по количеству элементов в корзине (с учетом amount).

select cust.id, cust.email
from public.customer cust
inner join public.carts carts on cust.id = carts.customer_id
order by amount desc
limit 10



