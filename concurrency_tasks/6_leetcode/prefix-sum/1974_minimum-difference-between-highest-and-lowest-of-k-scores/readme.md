Минимальная разница между самым высоким и самым низким из K баллов

Описание задачи:
Вам дан массив целых чисел nums, где nums[i] представляет собой оценку i-го студента, и целое число k. Необходимо выбрать оценки любых k студентов из массива так, чтобы разница между самой высокой и самой низкой из выбранных оценок была минимальной. Верните минимально возможную разницу.

Пример 1:

Ввод: nums = [90], k = 1  
Вывод: 0  
Объяснение: Есть только один способ выбрать оценки одного студента: [90].  
Разница между самой высокой и самой низкой оценкой равна 90 - 90 = 0.

Пример 2:

Ввод: nums = [9, 4, 1, 7], k = 2  
Вывод: 2  
Объяснение:  
- Возможные пары (k = 2): [9, 4], [9, 1], [9, 7], [4, 1], [4, 7], [1, 7].  
- Разница между самой высокой и самой низкой оценкой минимальна для пары [4, 7]: 7 - 4 = 3.

Подсказка:
Для минимизации разницы между самой высокой и самой низкой оценкой, можно отсортировать массив nums. После сортировки, минимальная разница будет найдена среди всех подмассивов длины k.

------

Для решения задачи мы используем подход с сортировкой и скользящим окном. Вот пошаговое объяснение:

1. **Сортировка массива**:
   - Сначала мы сортируем массив `nums` по возрастанию. Это позволяет нам легко находить минимальную разницу между `k` соседними элементами.

2. **Использование скользящего окна**:
   - После сортировки мы используем фиксированное окно длины `k`, чтобы найти минимальную разницу между самой высокой и самой низкой оценкой в этом окне.
   - Для этого заводим два указателя: левый (`l`) указывает на начало окна, а правый (`r`) — на конец окна. В начале `l = i`, а `r = i + k - 1`.

3. **Итерация по массиву**:
   - Мы проходим по массиву, начиная с индекса `i = 0` и заканчивая индексом `i = len(nums) - k`. На каждой итерации:
     - Вычисляем разницу между элементами `nums[r]` и `nums[l]`.
     - Сравниваем эту разницу с текущим минимальным результатом (`result`) и обновляем `result`, если новая разница меньше.

4. **Возврат результата**:
   - После завершения итерации возвращаем минимальную разницу, хранящуюся в `result`.

---

#### **Пример**
```
Ввод: nums = [8, 4, 2, 7, 9, 12, 0], k = 3
```

1. Сортируем массив:
   ```
   arr = [0, 2, 4, 7, 8, 9, 12]
   ```

2. Используем скользящее окно длины `k = 3`:
   - На первой итерации: `l = 0`, `r = 2`, окно = `[0, 2, 4]`, разница = `4 - 0 = 4`.
   - На второй итерации: `l = 1`, `r = 3`, окно = `[2, 4, 7]`, разница = `7 - 2 = 5`.
   - На третьей итерации: `l = 2`, `r = 4`, окно = `[4, 7, 8]`, разница = `8 - 4 = 4`.
   - На четвёртой итерации: `l = 3`, `r = 5`, окно = `[7, 8, 9]`, разница = `9 - 7 = 2`.
   - На пятой итерации: `l = 4`, `r = 6`, окно = `[8, 9, 12]`, разница = `12 - 8 = 4`.

3. Минимальная разница: `result = 2`.

**Вывод**:
```
Ответ: 2
```

---

#### **Почему работает сортировка?**
Сортировка гарантирует, что минимальная разница между `k` элементами будет найдена среди соседних чисел. Например, если число `2` входит в подмассив длины `k`, то оно может быть только в группах `[0, 2, 4, 7]` или `[2, 4, 7, 8]`. Другие группы не имеют смысла, так как они включают числа, которые находятся дальше от `2` и увеличивают разницу.

---

#### **Сложность**
- **Время**: `O(n log n)` — сортировка массива.
- **Память**: `O(1)` — если используется heap sort, или `O(n)` — если используется merge sort.

Самая сложная операция, которую мы используем в данной задачи это сортировка. Мы будем использовать стандартную сортировку, встроенную в язык. Нужно знать какую сложность она имеет. Если используется heap sort, то mem: O(1), если quicksort или mergesort, то mem может варьироваться от O(n) до O(logn).

В Go функция sort.Ints использует быструю сортировку (QuickSort) под капотом. 
sort.Ints использует QuickSort, который имеет среднюю временную сложность O(n log n) и худшую сложность O(n²) в редких случаях (например, если массив уже отсортирован в обратном порядке).
