Метод двух указателей — это эффективный способ решения задачи **"Three Sum"**. Вот пошаговая подсказка, как использовать этот метод:

---

### Шаги для решения задачи с использованием двух указателей:

#### 1. **Сортировка массива**
   - Сначала отсортируйте массив `nums`. Это важно, чтобы можно было эффективно использовать два указателя.
   - Пример: если `nums = [-1, 0, 1, 2, -1, -4]`, то после сортировки: `nums = [-4, -1, -1, 0, 1, 2]`.

#### 2. **Фиксируем первый элемент тройки**
   - Используйте цикл `for` для перебора каждого элемента массива как первого элемента тройки (`nums[i]`).
   - Пропускайте дубликаты, чтобы избежать повторяющихся троек. Если `nums[i] == nums[i-1]` (и `i > 0`), просто продолжайте к следующему элементу.

#### 3. **Используем два указателя для поиска оставшихся двух чисел**
   - После фиксации первого элемента (`nums[i]`), используйте два указателя:
     - **Левый указатель** (`left`), который начинается сразу после `i` (`left = i + 1`).
     - **Правый указатель** (`right`), который начинается с конца массива (`right = len(nums) - 1`).
   - Цель: найти такие `nums[left]` и `nums[right]`, чтобы их сумма с `nums[i]` была равна нулю:
     ```
     nums[i] + nums[left] + nums[right] == 0
     ```

#### 4. **Движение указателей**
   - Если сумма тройки больше нуля (`nums[i] + nums[left] + nums[right] > 0`), уменьшайте правый указатель (`right--`), чтобы уменьшить сумму.
   - Если сумма тройки меньше нуля (`nums[i] + nums[left] + nums[right] < 0`), увеличивайте левый указатель (`left++`), чтобы увеличить сумму.
   - Если сумма равна нулю, добавьте тройку в результат и:
     - Увеличьте левый указатель (`left++`) и уменьшите правый указатель (`right--`), чтобы продолжить поиск других троек.
     - Пропустите дубликаты: если `nums[left] == nums[left-1]`, увеличьте `left`, а если `nums[right] == nums[right+1]`, уменьшите `right`.

#### 5. **Повторяйте, пока `left < right`**
   - Продолжайте двигать указатели, пока они не пересекутся.

---

### Пример:
Для массива `nums = [-1, 0, 1, 2, -1, -4]`:

1. Сортируем массив: `nums = [-4, -1, -1, 0, 1, 2]`.
2. Фиксируем первый элемент:
   - `i = 0`, `nums[i] = -4`. Используем два указателя: `left = 1`, `right = 5`.
   - Сумма: `-4 + (-1) + 2 = -3` (меньше 0), увеличиваем `left`.
   - Продолжаем, пока `left < right`.
3. Следующий фиксированный элемент:
   - `i = 1`, `nums[i] = -1`. Используем два указателя: `left = 2`, `right = 5`.
   - Сумма: `-1 + (-1) + 2 = 0`. Добавляем тройку `[-1, -1, 2]` в результат.
   - Двигаем указатели и продолжаем.
4. Повторяем для всех элементов.

### Сложность:
- **Временная сложность**: `O(n^2)` — из-за внешнего цикла и внутреннего поиска с двумя указателями.
- **Пространственная сложность**: `O(1)` (не считая результата).

Этот метод эффективен и позволяет избежать лишних вычислений благодаря сортировке и пропуску дубликатов.