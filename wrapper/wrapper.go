package main

import "fmt"

// Определяем интерфейс для базового типа
type Base interface {
	DoSomething()
}

// Реализуем базовый тип
type ConcreteBase struct{}

func (c *ConcreteBase) DoSomething() {
	fmt.Println("Базовый тип выполняет действие")
}

// Определяем обертку
type Wrapper struct {
	Base
}

func (w *Wrapper) DoSomething() {
	fmt.Println("Обертка выполняет действие перед базовым типом")
	w.Base.DoSomething()
	fmt.Println("Обертка выполняет действие после базового типа")
}

func main() {
	// Создаем экземпляр базового типа
	base := &ConcreteBase{}

	// Создаем экземпляр обертки
	wrapper := &Wrapper{base}

	// Вызываем метод обертки, который вызывает метод базового типа
	wrapper.DoSomething()
}

// В этом примере мы определяем интерфейс  Base, который представляет базовый тип.
// Затем мы реализуем этот интерфейс с помощью структуры  ConcreteBase, которая просто выводит сообщение в консоль.

// Затем мы определяем обертку Wrapper, которая включает в себя экземпляр базового типа.
// Метод DoSomething() обертки вызывает метод базового типа, но перед этим и после этого выполняет свои действия.

// В функции main мы создаем экземпляр базового типа и обертки, и вызываем метод  DoSomething() обертки, который вызывает метод базового типа.

// Этот пример демонстрирует, как можно использовать паттерн проектирования wrapper в Go
// для добавления дополнительной функциональности к существующему типу данных.
