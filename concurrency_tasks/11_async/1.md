https://stepik.org/lesson/1131159/step/1?unit=1142756  -4:21

### cgi-bin

![cgi-bin](images/cgi-bin.png)

Одно соединение - один процесс. Если много запросов - упремся в память.

На каждый запрос создается новый процесс. Это операция очень тяжелая. Выполняет запрос и после этого процесс убивается.

Это неэффективно. Мы тратим много времени и ресурсов на создание и звершение процессов.

### worker pool

В этом случае у нас есть н есколько процессов, которые не убиваются после завершения запросов, а остаются в ожидании следующего запроса.

### Multithreading

![multithreading](images/multithreading.png)

Мы создаем не целый процесс, а системный тред. Тред более легкая сущность, чем процесс. Тред имеет доступ к оперативной памяти своего процесса. В нем можно переиспользовать соединения к базе данных. Тред занимает меньше памяти. Системный тред тоже выполняется процессором и у него тоже есть context switch. За счет экономии памяти мы можем обработать большее количество запросов.

Также мы можем создать worker pool и переиспользовать треды, не создавая их снова. Возможно это можно как-то ускорить? Давайте посмотрим внутрь запроса.

### А что внутри запроса?

![request](images/request.png)

Основное время внутри API уходит на ожидание от какой-то БД или веб-сервиса. В случае с подходом с процессами на запрос или тредами на запрос получается, что тред блокируется на ожидание ответа и не выполняет никакой полезной работы. 

### non blocking i/o на 1 ядре

![non-blocking_io](images/non-blocking_io.png)

Из этого понимания родился событийный подход понимания процессора, который реалиозован в node JS и JS. У нас не блокирующий ввод/вывод (I/O). После отправки запроса в БД мы не блокируемся и продолжаем выполнять какие-то другие запросы. В этом случае процессор у нас перестает бездействовать и мы получаем хорошее быстродействие. Мы можем обработаывать много запросов внутри одного треда.

### non blocking i/o на 1 ядре

![non-blocking_io_2](images/non-blocking_io_2.png)

