59:00

Нам нужно определить симметричное ли это дерево. То есть если провести воображаемую линию у нас правые и левые поддеревья должны быть симметричны отчносительно друг друга.

01:01:34 Мы будем идти вот так, а потом вот так.

Важный краевой случай if root == nil, при котором ломается программа, потому что мы не может перейти по правому и левому поддереву.

Оценка памяти и времени:
time: O(n), где n - количество элементов в дереве
mem: O(h) или O(n) - оценка сверху, в котором мы не учитываем константы

1:08:00 Есть интересный сайт, в котором есть куски кода, в которых нужно оценить сложность алгоритма. Очень хорошая тренировка. Спросить у Максима.

У нас есть функция check для проверки значений дерева на симметрию. В самом начале мы смотрим не равны ли значения nil.
Если мы зашли в следующее условие l.Val != r.Val значит значения точно не равны nil
Далее у нас идет третий случай, который состоит из двух - check(l.Left, r.Right) и check(l.Right, r.Left). 