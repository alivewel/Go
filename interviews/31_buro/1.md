- Задача 1 (что будет выведено?):
package main

import "fmt"

func main(){
    s1 := []int{1,2,3}
    s2 := s1[1:]
    s2 = append(s2, 4)
    s2[0] = 10

    fmt.Println(s1)
    fmt.Println(s2)
}

Доп. вопрос по задаче 1:
Что нужно сделать, чтобы 9-я строчка затрагивала и s1?

- Задача 2 (что будет выведено?):
package main

import "fmt"

func main(){
    a := make([]int, 0, 4)
    a = append(a, 1,2,3)
    appendSlice(a)
    fmt.Println(a[:])
    fmt.Println(a[:4])
}

func appendSlice(a []int) {
    a = append(a, 4)
}

- Задача 3 (что не нравится в коде?):
package main

import (
    "fmt"
    "sync"
)

var counter int

func main() {
    var wg sync.WaitGroup
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            counter++
        }()
    }
    wg.Wait()
    fmt.Println(counter)
}

После просят рассказать про атомики, rwmutex, что когда лучше применять и так далее

- Задача 4 (что будет выведено?):
package main

import (
    "fmt"
)

func test() int {
    x := 5
    defer func() {
        x = x + 10
    }()

    return x
}

func main() {
    fmt.Println(test())
}

- Задача 5 (что будет выведено?):
package main

import (
    "fmt"
)

func main() {
    m := make(map[string]int)
    m["a"] = 1

    p := &m["a"]
    *p = 42

    fmt.Println(m)
}

После подробно про мапу, что такое, как устроено, как эвакуация происходит

- Задача 6 (что будет выведено?):
package main

import (
    "fmt"
)

func main() {
    a := []int{1, 2, 3}
    b := []int{1, 2, 3}
    fmt.Println(a == b)
}

- А так?
package main

import (
    "fmt"
)

func main() {
    a := [3]int{1, 2, 3}
    b := [3]int{1, 2, 3}
    fmt.Println(a == b)
}


- Задача 7 (что будет? как исправить?):
package main

import (
    "fmt"
)

func main() {
    ch := make(chan int)
    ch <- 42
    val := <-ch
    fmt.Println(val)
}

- Задача 8 (стандартная задача на семафор, но условие не вспомню)

- Задача 9:
package main

import (
    "context"
    "fmt"
    "time"
)

/*
Если функция process долго выполняется, то вывести 0 иначе 1
*/
const processingMaxTimeout = 3 * time.Second

func main() {
    var result int

    ctx, cancel := context.WithTimeout(context.Background(), processingMaxTimeout)
    defer cancel()

    // === edit here ===

 

    // =================

    fmt.Println(result)
}

func process() int {
    // long processing job
    time.Sleep(time.Second * 2)

    return 1
}

- Задача 10 на SQL:
Точное условие не помню, но там дефолтный join + агрегация. Ну вопрос, в чем отличие having от where.