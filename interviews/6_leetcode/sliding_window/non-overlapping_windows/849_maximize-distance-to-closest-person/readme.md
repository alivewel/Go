### **Maximize Distance to Closest Person (LeetCode 849)**

#### **Условие задачи**
Вам дан массив `seats`, где `seats[i] = 1` означает, что место занято, а `seats[i] = 0` — свободно.  
Гарантируется, что в массиве есть хотя бы одно занятое место (`1`).  

Ваша задача — найти максимальное возможное расстояние от свободного места (`0`) до ближайшего занятого (`1`) и вернуть это расстояние.

---

#### **Примеры**

##### **Пример 1**
**Вход**:  
```go
seats = []int{1, 0, 0, 0, 1, 0, 1}
```
**Объяснение**:
```
1  0  0  0  1  0  1
   ^        ^
```
- Человек может сесть на `index = 2` (между `1`), расстояние до ближайшего `1` равно `2`.
- Или на `index = 5`, расстояние равно `1`.
- Максимальное расстояние: **2**.

**Выход**:  
```go
2
```

---

##### **Пример 2**
**Вход**:  
```go
seats = []int{1, 0, 0, 0}
```
**Объяснение**:
```
1  0  0  0
   ^
```
- Можно сесть на `index = 3`, расстояние до `1` будет **3**.

**Выход**:  
```go
3
```

---

##### **Пример 3**
**Вход**:  
```go
seats = []int{0, 1}
```
**Объяснение**:
```
0  1
^
```
- Единственный свободный `0` на `index = 0` имеет расстояние **1** до ближайшего `1`.

**Выход**:  
```go
1
```

---

### **Подход к решению**
1. Найти последовательности `0` в массиве.
2. Если `0` в начале (`0001`) или в конце (`1000`), расстояние равно длине последовательности `0`.
3. Если `0` между двумя `1`, лучше сесть в середине блока, используя формулу:
   \[
   \text{(количество нулей + 1)} / 2
   \]
4. Вернуть **максимальное** расстояние среди всех возможных вариантов.

---

Это стандартная задача на работу с массивами и последовательностями. Ты можешь использовать сканирование массива с двумя указателями (`l` и `r`), чтобы находить блоки `0` и вычислять их длину.
