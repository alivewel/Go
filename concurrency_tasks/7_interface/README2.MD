https://www.youtube.com/watch?v=eYHCCht8eX4
Где лучше размещать интерфейс?
Короткий ответ - интерфейсы лучше размещать в месте их использования. Рекомендация - интерфейсы должны быть минималистичными.
Интерфейс ничего не должен знать о типах, которые его реализуют

Пример некого сервиса. В этом сервисе нас интересует 2 слоя: storage и handlers. В слое storage есть пакет users в котором указаны методы для различных БД: postgres, redis, mysql и т.д. Для того, чтобы не зависеть от типа реализации мы решили описать общий интерфейс, который называется storage. В общем интерфейсе содержаться все методы, которые необходимы для взаимодействия со всеми БД.

Кажется, что мы соблюдаем правило №2 - Интерфейс ничего не должен знать о типах, которые его реализуют, но это не так.

Мы используем данный интерфейс в слой handlers. В частности в нем у нас есть функция New, которая принимает интерфейс Storage в котором множество методов.

Чтобы не тащить за собой огромный интерфейс, в котором куча методов, мы можем описать интерфейс в месте его использования, прямо в этом хендлере. В этом хендлере мы используем один единственный метод User(). Это значит, что мы можем создать здесь интерфейс в котором будет необходимый метод. Создадим интерфейс UserProvider, в котором будет метод User(). 
Что нам это дает?

Мы получили минималистичный интерфейс, в нашем методе нет намека о какой-либо БД. Метод User() просто каким-то образом возвращает пользователя.

Мы уменьшими связность. Пакет handlers никак не зависит от пакета storage. Связность компонентов системы должна быть как можно меньше.

Понятность кода.
Мы сделали ясными ожидание и потребности разных частей системы. При чтении кода в пакете handlers мы видим какой интерфейс ожидает функция и этот интерфейс описан в этом же пакете. При получении большого интерфейса Storage мы видим, что у него много методов и не сразу понятно, для чего они нужны. Также, чтобы прочитать описание интерфейса нужно перейти в другой пакет.

Гибкость системы.
Допустим мы хотим передать вместе сущности Postgres сущность Redis, для того, чтобы соответствовать данному интерфейсу нам придется реализовать всего его методы, даже если они не используются.

Тестирование.
При написании юнит-тестов для тестирования логики  функции нам необходимо изолироваться от какой-либо БД. Mock'и позволяют нам этого добиться. Поскольку интерфейс описан в пакете handlers, то и сгенерировать mock мы можем в этом же пакете.

Из минусов это дублирование описания интерфейса по всем частям сервиса. Если мы захотим изменить сигнатуры методов, то нам придется это сделать во всех частях системы. Если бы у нас был один общий интерфейс, нам нужно было бы изменить его только в одном месте.

Новичкам из других языков не всегда понятен такой подход, который связан с утиной типизации в go.