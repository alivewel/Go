Table "public.carts"
| Column       | Type                          | Modifiers          |
|--------------|-------------------------------|--------------------|
| sku          | bigint                        | not null           |
| country      | country_enum                  | not null           |
| customer_id  | bigint                        | not null           |
| amount       | bigint                        | not null           |
| updated_at   | timestamp without time zone   | default now()      |

Table "public.customer"
| Column       | Type                          | Modifiers          |
|--------------|-------------------------------|--------------------|
| id           | bigint                        | not null           |
| email        | text                          | not null           |

SKU (Stock Keeping Unit) — уникальный идентификатор товара на складе. Используется для учета и идентификации товаров.

1) 
-- Вывести построчно всех кастомеров (id, email)
-- и все элементы корзины пользователя (sku, amount)

select cust.id, cust.email, carts.sku, carts.amount
from public.customer cust
inner join public.carts carts on cust.id = carts.customer_id
order by 1

INNER JOIN и JOIN в SQL на самом деле являются одним и тем же. Когда вы используете просто JOIN, это подразумевает INNER JOIN по умолчанию. 

При использовании JOIN у нас выведутся только те пользователи у которых есть покупки.
Если мы хотим вывести всех пользователей нужно использовать LEFT JOIN.

Указание полей в SQL-запросе
Если название полей присутствует только в одной таблице, то вы можете не указывать префикс таблицы для этих полей. Однако, даже в этом случае, использование префиксов может улучшить читаемость и понимание запроса, особенно если вы работаете с несколькими таблицами.

Какие типы джойнов еще знаешь?
Left join, right join, FULL JOIN, inner join

### Как работает FULL JOIN?

Основные характеристики FULL JOIN:
Возвращает все строки:
FULL JOIN возвращает все строки из обеих таблиц. Если в одной из таблиц нет соответствующей строки, то в результирующем наборе данных будут заполнены значения NULL для отсутствующих данных.
Сочетание LEFT JOIN и RIGHT JOIN:
FULL JOIN можно рассматривать как объединение результатов LEFT JOIN и RIGHT JOIN. Это означает, что он показывает как совпадающие строки, так и строки, которые не совпадают в обеих таблицах.
NULL значения:
Когда строки из одной таблицы не имеют соответствующих строк в другой таблице, в результирующем наборе данных будут присутствовать NULL значения для столбцов, которые не имеют соответствующих данных.

### Какой тип джойна будет в данном случае?
select *
from public.customer, public.carts

Когда необходимо объединить данные из двух таблиц, включая все строки из обеих таблиц, даже если для некоторых строк нет совпадений, то в этом случае будет использоваться FULL JOIN.

### У нас в таблице public.carts появились записи, у которых нет пользователя. Как вывести такие записи?

select *
from public.carts
where customer_id IS NULL;

а если наоборот, то

SELECT *
FROM public.carts
WHERE customer_id IS NOT NULL;

### Какие индексы ты использовал?

1. GiST (Generalized Search Tree)
Описание: GiST — это обобщенное дерево поиска, которое позволяет создавать индексы для различных типов данных и операций. Он может использоваться для хранения данных, которые не подходят для традиционных B-tree индексов.
Применение: GiST хорошо подходит для работы с геометрическими данными, полнотекстовым поиском и другими сложными типами данных. Например, его можно использовать для индексации данных типа geometry или jsonb.
Преимущества: GiST позволяет выполнять запросы с использованием различных операторов, что делает его гибким инструментом для индексирования. Он также поддерживает диапазонные запросы и может эффективно обрабатывать сложные условия поиска.
2. GIN (Generalized Inverted Index)
Описание: GIN — это обобщенный инвертированный индекс, который особенно полезен для индексации данных, содержащих множество значений, таких как массивы или документы JSON.
Применение: GIN идеально подходит для полнотекстового поиска и индексации массивов. Например, если у вас есть столбец с массивами, GIN индекс позволит быстро находить строки, содержащие определенные элементы массива.
Преимущества: GIN индексы обеспечивают высокую производительность для запросов, которые ищут по множеству значений. Однако они могут занимать больше места на диске и требовать больше времени на обновление по сравнению с B-tree индексами.
3. Hash
Описание: Hash индексы используют хеш-функцию для быстрого поиска строк по значению. Они предназначены для операций равенства.
Применение: Hash индексы могут быть полезны, когда вы часто выполняете запросы с условиями равенства, например, WHERE customer_id = 123.
Преимущества: Hash индексы обеспечивают быструю производительность для операций равенства. Однако они не поддерживают операции сравнения (например, >, <), и в PostgreSQL они менее распространены, чем B-tree индексы.

### И какой индекс стоит использовать для ускорения запросов с customer_id?

CREATE INDEX idx_customer_id ON public.carts (customer_id);

-- по умолчанию PostgreSQL создает B-tree индекс. B-tree индекс: Это наиболее распространенный тип индекса в PostgreSQL, который хорошо подходит для операций поиска, сортировки и диапазонных запросов. Он эффективно обрабатывает запросы на равенство и неравенство, что делает его идеальным для столбцов, таких как customer_id

### Какие минусы от использования индексов?

1. Увеличение затрат на хранение
Индексы занимают дополнительное место на диске. Каждый индекс требует хранения структуры данных, что может привести к значительному увеличению объема базы данных, особенно если индексов много или они создаются на больших таблицах.
2. Замедление операций записи
При добавлении, обновлении или удалении данных в таблице, все соответствующие индексы также должны быть обновлены. Это может привести к увеличению времени выполнения операций записи, так как система должна поддерживать актуальность индексов.
3. Сложность управления
С увеличением количества индексов может возникнуть сложность в управлении ими. Необходимость периодически пересматривать и оптимизировать индексы может потребовать дополнительных ресурсов и времени.
4. Потенциальное ухудшение производительности
В некоторых случаях наличие слишком большого количества индексов может ухудшить производительность запросов. Это связано с тем, что оптимизатор запросов может выбирать менее эффективный индекс для выполнения запроса, что приведет к увеличению времени выполнения.
5. Необходимость анализа и тестирования
Для эффективного использования индексов необходимо проводить анализ и тестирование, чтобы определить, какие индексы действительно нужны. Это требует времени и ресурсов, особенно в больших и сложных базах данных.

### Допустим у нас есть большая таблица и мы добавляем новый индекс на колонку (столбец). В продакшене таблица на терабайт данных и мы на колонку вешаем индекс. Какие проблемы могут быть? Что происходит с таблицей под капотом, когда мы добавляем индекс? Произойдет блокировка таблицы. Как избежать блокировку? Альтернативный способ создания индекса без блокировки таблицы?

Чтобы избежать блокировки таблицы при создании индекса, вы можете использовать команду CREATE INDEX с опцией CONCURRENTLY. Это позволяет создавать индекс без блокировки таблицы для операций чтения и записи. 

Преимущества создания индекса с использованием CONCURRENTLY
Отсутствие блокировок: Таблица остается доступной для других операций, что минимизирует влияние на производительность приложения.
Постепенное создание: Индекс создается в фоновом режиме, что позволяет системе продолжать обрабатывать запросы.

Ограничения
Необходимо учитывать: Создание индекса с использованием CONCURRENTLY может занять больше времени, чем обычное создание индекса, и не может быть выполнено в транзакциях.
Ошибки: Если в процессе создания индекса произойдет ошибка, индекс не будет создан, и вам, возможно, придется повторить попытку.

Альтернативный способ создания индекса без блокировки:
Создание индекса на копии таблицы: Вы можете создать новую таблицу с нужным индексом, скопировать данные из старой таблицы в новую, а затем переименовать таблицы. Это требует больше усилий, но позволяет избежать блокировок.

### Составные индексы в PostgreSQL
Составные индексы (или комбинированные индексы) представляют собой индексы, которые создаются на нескольких столбцах таблицы. Они позволяют оптимизировать запросы, которые фильтруют данные по нескольким полям одновременно.
Преимущества составных индексов
Улучшение производительности запросов: Составные индексы могут значительно ускорить выполнение запросов, которые используют условия фильтрации по нескольким столбцам. Например, если у вас есть запрос, который фильтрует по major и minor, создание составного индекса на этих двух столбцах позволит базе данных быстрее находить соответствующие строки.
Оптимизация использования памяти: Вместо создания отдельных индексов для каждого столбца, составные индексы позволяют объединить несколько столбцов в одном индексе, что может быть более эффективно с точки зрения использования памяти.
Поддержка сложных запросов: Составные индексы могут быть полезны для сложных запросов, которые используют несколько условий, например, WHERE, ORDER BY и GROUP BY, что делает их особенно полезными в аналитических задачах.
Создание составного индекса
Чтобы создать составной индекс, вы можете использовать следующий синтаксис:
sql


CREATE INDEX idx_name ON table_name (column1, column2);
Например, если у вас есть таблица test2 с колонками major и minor, вы можете создать составной индекс следующим образом:
sql


CREATE INDEX test2_mm_idx ON test2 (major, minor);
Порядок столбцов в индексе
Важно учитывать порядок столбцов в составном индексе. Первый столбец в индексе имеет наибольшее значение для производительности запросов. Если запросы часто фильтруются по major, а затем по minor, то правильный порядок будет именно таким: (major, minor). Если же порядок будет обратным, индекс может не использоваться эффективно для некоторых запросов.

1:10:00

2) Вывести топ-10 клиентов (id, email) по количеству элементов в корзине (с учетом amount).

select cust.id, cust.email
from public.customer cust
inner join public.carts carts on cust.id = carts.customer_id
order by amount desc
limit 10



