–û—Ç–ª–∏—á–Ω–æ! –ù–∏–∂–µ –¥–≤–∞ –ø—Ä–∏–º–µ—Ä–∞:

---

# ‚úÖ **–ü—Ä–∏–º–µ—Ä 1: Lock-Free –°—á—ë—Ç—á–∏–∫ —Å CAS**

–≠—Ç–æ –±–∞–∑–æ–≤—ã–π –ø—Ä–∏–º–µ—Ä: **–±–µ–∑–æ–ø–∞—Å–Ω—ã–π –∏–Ω–∫—Ä–µ–º–µ–Ω—Ç —Å—á—ë—Ç—á–∏–∫–∞**, –±–µ–∑ `Mutex`, —Ç–æ–ª—å–∫–æ —Å `CAS`.

```go
package main

import (
	"fmt"
	"sync"
	"sync/atomic"
)

type Counter struct {
	value int64
}

func (c *Counter) Inc() {
	for {
		old := atomic.LoadInt64(&c.value)
		if atomic.CompareAndSwapInt64(&c.value, old, old+1) {
			return
		}
	}
}

func (c *Counter) Value() int64 {
	return atomic.LoadInt64(&c.value)
}

func main() {
	var c Counter
	var wg sync.WaitGroup

	for i := 0; i < 1000; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			c.Inc()
		}()
	}

	wg.Wait()
	fmt.Println("Final value:", c.Value()) // –î–æ–ª–∂–Ω–æ –±—ã—Ç—å 1000
}
```

---

# ‚úÖ **–ü—Ä–∏–º–µ—Ä 2: Lock-Free Queue (—É–ø—Ä–æ—â—ë–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)**

–ù–∏–∂–µ –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π lock-free queue —Å –ø–æ–º–æ—â—å—é `CAS`, –æ—Å–Ω–æ–≤–∞–Ω–Ω—ã–π –Ω–∞ **Michael‚ÄìScott Queue** (MSQueue). –≠—Ç–æ **—Å–ª–æ–∂–Ω–µ–µ**, –Ω–æ –º–æ—â–Ω–µ–µ.

```go
package main

import (
	"fmt"
	"sync/atomic"
	"unsafe"
)

type node struct {
	value interface{}
	next  unsafe.Pointer // *node
}

type LockFreeQueue struct {
	head unsafe.Pointer // *node
	tail unsafe.Pointer // *node
}

func NewQueue() *LockFreeQueue {
	dummy := unsafe.Pointer(&node{})
	return &LockFreeQueue{head: dummy, tail: dummy}
}

func (q *LockFreeQueue) Enqueue(v interface{}) {
	newNode := &node{value: v}
	for {
		tail := load(&q.tail)
		next := load(&tail.next)
		if tail == load(&q.tail) {
			if next == nil {
				if cas(&tail.next, next, newNode) {
					cas(&q.tail, tail, newNode)
					return
				}
			} else {
				cas(&q.tail, tail, next)
			}
		}
	}
}

func (q *LockFreeQueue) Dequeue() (interface{}, bool) {
	for {
		head := load(&q.head)
		tail := load(&q.tail)
		next := load(&head.next)

		if head == load(&q.head) {
			if head == tail {
				if next == nil {
					return nil, false // –ü—É—Å—Ç–æ
				}
				cas(&q.tail, tail, next)
			} else {
				val := next.value
				if cas(&q.head, head, next) {
					return val, true
				}
			}
		}
	}
}

// helpers
func load(p *unsafe.Pointer) *node {
	return (*node)(atomic.LoadPointer(p))
}

func cas(p *unsafe.Pointer, old, new *node) bool {
	return atomic.CompareAndSwapPointer(p, unsafe.Pointer(old), unsafe.Pointer(new))
}
```

### –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:

```go
func main() {
	q := NewQueue()
	q.Enqueue("hello")
	q.Enqueue("world")

	if v, ok := q.Dequeue(); ok {
		fmt.Println(v) // hello
	}
	if v, ok := q.Dequeue(); ok {
		fmt.Println(v) // world
	}
}
```

---

## üöÄ –†–µ–∑—é–º–µ

* `atomic` –∏ `CAS` –ø–æ–∑–≤–æ–ª—è—é—Ç –ø–∏—Å–∞—Ç—å –≤—ã—Å–æ–∫–æ–ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω—ã–µ **lock-free** —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö.
* –ü–æ–¥—Ö–æ–¥—ã —Å `CAS` **–±—ã—Å—Ç—Ä–µ–µ**, –Ω–æ —Å–ª–æ–∂–Ω–µ–µ –∏ —Ç—Ä–µ–±—É—é—Ç –æ—Å—Ç–æ—Ä–æ–∂–Ω–æ—Å—Ç–∏:

  * –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ –∞—Ç–æ–º–∞—Ä–Ω–æ –æ–±–Ω–æ–≤–∏—Ç—å –¥–≤–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ;
  * –ª–µ–≥–∫–æ –¥–æ–ø—É—Å—Ç–∏—Ç—å –æ—à–∏–±–∫—É –ø—Ä–∏ —Ä–∞–±–æ—Ç–µ —Å `unsafe.Pointer`.

---

–•–æ—á–µ—à—å –∞–Ω–∞–ª–æ–≥–∏—á–Ω—ã–π –ø—Ä–∏–º–µ—Ä –¥–ª—è **lock-free —Å—Ç–µ–∫–∞ (stack)** –∏–ª–∏ **—Å–µ–º–∞—Ñ–æ—Ä–∞ –Ω–∞ `atomic`?**
