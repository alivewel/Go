00:00:00 — Вступление
00:00:35 — Начало собеседования
00:00:40 — Описание формата собеседования
00:01:23 — Расскажи про предыдущие проекты
00:05:03 — За счёт чего обеспечивается отказоустойчивость Кафки?
00:05:40 — Какие гарантии доставки предоставляет Кафка?
00:06:20 — Что подразумевает под собой гарантия доставки "at most once"?
00:06:42 — Что подразумевает под собой гарантия доставки "at least once"?
00:06:54 — Что делать, если у нас "at least once", но при этом бизнес-логика чувствительна к дубликатам запросов?
00:07:58 — Какие плюсы и минусы микросервисной архитектуры?
00:09:12 — Расскажи что знаешь про распределённые транзакции
00:10:17 — Как решается проблема дубликатов входящих запросов?
00:12:15 — Лайвкодинг: первая задача
00:12:19 — Что выведет программа?
00:13:48 — Как устроен слайс?
00:14:05 — Как работает append?
00:14:41 — Какая временная сложность доступа к элементам слайса?
00:14:55 — Какая временная сложность добавления элемента в конец слайса?
00:15:33 — Как бы ты исправил представленную программу, чтобы foo() не влияла на arr?
00:16:00 — Кривой вопрос про то можно ли предвыделить память при помощи make()
00:19:54 — Лайвкодинг: вторая задача
00:19:56 — Что выведет программа?
00:20:43 — Что бы ты улучшил в представленной программе?
00:21:38 — Почему wg.Add(1) нельзя делать прямо в начале ожидаемой горутины?
00:22:49 — В какой последовательности в представленной программе отработают запущенные горутины?
00:23:02 — Какие проблемы могут быть, если в представленной программе в urls будет 100k урлов?
00:23:50 — Как можно обойти эти проблемы?
00:24:36 — Расскажи про планировщик
00:26:00 — Что такое горутина?
00:27:56 — В какой момент происходит переключение горутин?
00:28:50 — Какой-то странный вопрос про поведение планировщика при сетевых запросах
00:29:41 — Что такое надполяр?
00:29:50 — Что происходит с горутиной, когда она блокируется на чтении файла?
00:30:15 — Какие отличия между сетевым запросом и чтением из файла с точки зрения планировщика?
00:31:28 — Исправь представленную программу, чтобы как только какая-нибудь горутина ответила с ошибкой, то программа завершилась
00:35:42 — Что такое context?
00:36:27 — Какие контексты бывают?
00:36:39 — Для чего используется context.WithValue?
00:37:43 — Лайвкодинг: третья задача
00:37:36 — Что выведет программа?
00:39:03 — Как обнаружить гонку?
00:39:21 — Что будет, если в программе мы будем читать по ключу "a", а писать по ключу "b"?
00:39:48 — Как избежать гонки в представленной программе?
00:40:51 — Чем отличаются Mutex и RWMutex?
00:42:18 — Почему ты предпочитаешь использовать map+RWMutex, а не sync.Map?
00:43:37 — Какие примитивы синхронизации ты знаешь?
00:44:43 — Какие ключи можно использовать для мапы?
00:45:44 — Как устроена мапа?
00:46:34 — Лайвкодинг: четвёртая задача
00:46:38 — Что выведет программа?
00:48:18 — Как поправить представленную программу?
00:50:01 — Лайвкодинг: пятая задача
00:51:09 — Начинаю писать решение
00:55:05 — Лайвкодинг: шестая задача
00:55:06 — Что выведет программа?
00:56:02 — Как поправить программу?
00:56:43 — Для чего используются интерфейсы? Что можешь сказать про dependency injection?
00:59:30 — Сталкивался ли с чистой/гексогональной архитектурой?
00:59:40 — Расскажи про многослойную архитектуру
01:00:52 — Что такое интерфейс any?
01:01:23 — Как работать с any?
01:03:12 — Базы данных: первая задача
01:07:15 — Индексы в базах данных
01:10:57 — Базы данных: вторая задача
01:17:13 — Базы данных: третья задача
01:17:44 — Составные индексы
01:23:34 — Базы данных: четвёртая задача (жоска туплю, транзакции + блокировки и прочие радости)
01:45:07 — Заключение, разговор по душам
